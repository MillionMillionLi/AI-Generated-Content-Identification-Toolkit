# ç»Ÿä¸€å¤šæ¨¡æ€æ°´å°å·¥å…·è®¾è®¡æ–‡æ¡£

## ğŸ¯ é¡¹ç›®ç›®æ ‡

å¼€å‘ä¸€ä¸ªåŠŸèƒ½å®Œå–„çš„ç»Ÿä¸€å¤šæ¨¡æ€æ°´å°å·¥å…·ï¼Œæ”¯æŒï¼š

### ğŸ“‹ æ”¯æŒæ¨¡æ€ä¸ç®—æ³•
- **æ–‡æœ¬æ°´å°**ï¼šåŸºäºCredIDç®—æ³•çš„LLMæ–‡æœ¬æ°´å°ï¼ˆä»…AIç”Ÿæˆæ¨¡å¼ï¼‰
- **å›¾åƒæ°´å°**ï¼šåŒåç«¯æ”¯æŒï¼ˆVideoSealé»˜è®¤ï¼ŒPRC-Watermarkå¯é€‰ï¼‰
- **éŸ³é¢‘æ°´å°**ï¼šåŸºäºAudioSealç®—æ³•ï¼Œå®Œæ•´é›†æˆBarkæ–‡æœ¬è½¬è¯­éŸ³æ”¯æŒ
- **è§†é¢‘æ°´å°**ï¼šåŸºäºHunyuanVideoç”Ÿæˆ + VideoSealæ°´å°æŠ€æœ¯æ ˆ

### ğŸŒŸ æ ¸å¿ƒç‰¹æ€§
- **åŒæ¨¡å¼æ”¯æŒ**ï¼šæ¯ä¸ªæ¨¡æ€éƒ½æ”¯æŒ"AIç”Ÿæˆå†…å®¹"å’Œ"ä¸Šä¼ ç°æœ‰æ–‡ä»¶"ä¸¤ç§å¤„ç†æ¨¡å¼
- **ç»Ÿä¸€æ¥å£**ï¼šæä¾›ä¸€è‡´çš„`embed()`å’Œ`extract()`APIæ¥å£
- **å¯¹æ¯”æ˜¾ç¤º**ï¼šWebç•Œé¢è‡ªåŠ¨ä¿å­˜å¹¶æ˜¾ç¤ºåŸæ–‡ä»¶vsæ°´å°æ–‡ä»¶çš„å¹¶æ’å¯¹æ¯”
- **å¯è§æ ‡è¯†åˆè§„**ï¼šæ”¯æŒAIç”Ÿæˆå†…å®¹çš„æ˜¾å¼æ ‡è¯†ï¼Œæ»¡è¶³ç›‘ç®¡è¦æ±‚
- **ç¦»çº¿ä¼˜å…ˆ**ï¼šä¼˜å…ˆä½¿ç”¨æœ¬åœ°æ¨¡å‹ç¼“å­˜ï¼Œé¿å…ç½‘ç»œä¾èµ–
- **æµè§ˆå™¨å…¼å®¹**ï¼šè§†é¢‘/éŸ³é¢‘æ–‡ä»¶è‡ªåŠ¨è½¬ç ç¡®ä¿è·¨æµè§ˆå™¨Webæ’­æ”¾
- **é…ç½®é©±åŠ¨**ï¼šYAMLé…ç½®æ–‡ä»¶ç®¡ç†æ‰€æœ‰å‚æ•°ï¼Œæ”¯æŒè¿è¡Œæ—¶è°ƒæ•´

## ğŸ“ ç›®å½•ç»“æ„ä¸å±‚çº§å…³ç³»ï¼ˆå½“å‰å®ç°ï¼‰

```
unified_watermark_tool/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ default_config.yaml             # ç»Ÿä¸€é…ç½®æ–‡ä»¶ï¼ˆæ‰€æœ‰æ¨¡æ€ï¼‰
â”‚   â””â”€â”€ text_config.yaml                # æ–‡æœ¬æ°´å°ä¸“ç”¨é…ç½®
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ unified/                        # ç»Ÿä¸€å¼•æ“ä¸é«˜å±‚é—¨é¢
â”‚   â”‚   â”œâ”€â”€ unified_engine.py           # UnifiedWatermarkEngineï¼ˆæ”¯æŒåŒæ¨¡å¼ï¼‰
â”‚   â”‚   â””â”€â”€ watermark_tool.py           # é«˜å±‚å°è£…ï¼šæ¨èå…¥å£
â”‚   â”œâ”€â”€ text_watermark/                 # æ–‡æœ¬æ°´å°ï¼ˆCredIDï¼Œä»…AIç”Ÿæˆï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ credid_watermark.py         # CredIDç®—æ³•é«˜çº§å°è£…
â”‚   â”‚   â””â”€â”€ credid/                     # CredIDæ¡†æ¶ï¼ˆwatermarking/attacks/...ï¼‰
â”‚   â”œâ”€â”€ image_watermark/                # å›¾åƒæ°´å°ï¼ˆåŒåç«¯+åŒæ¨¡å¼ï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ image_watermark.py          # ç»Ÿä¸€å›¾åƒæ¥å£ï¼ˆæ‡’åŠ è½½åç«¯é€‰æ‹©ï¼‰
â”‚   â”‚   â”œâ”€â”€ prc_watermark.py            # PRC-Watermarkåç«¯
â”‚   â”‚   â”œâ”€â”€ PRC-Watermark/              # PRCç®—æ³•å®ç°
â”‚   â”‚   â””â”€â”€ videoseal_image_watermark.py# VideoSealå›¾åƒåç«¯ï¼ˆé»˜è®¤ï¼‰
â”‚   â”œâ”€â”€ audio_watermark/                # éŸ³é¢‘æ°´å°ï¼ˆåŒæ¨¡å¼æ”¯æŒï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ audio_watermark.py          # ç»Ÿä¸€éŸ³é¢‘æ¥å£ï¼ˆæ”¯æŒTTS+ä¸Šä¼ ï¼‰
â”‚   â”‚   â”œâ”€â”€ audioseal_wrapper.py        # AudioSealæ ¸å¿ƒå°è£…
â”‚   â”‚   â”œâ”€â”€ bark_generator.py           # Bark TTSé›†æˆ
â”‚   â”‚   â”œâ”€â”€ utils.py                    # éŸ³é¢‘I/Oã€è´¨é‡è¯„ä¼°ã€å¯è§†åŒ–
â”‚   â”‚   â””â”€â”€ audioseal/                  # AudioSealç®—æ³•å®ç°
â”‚   â”œâ”€â”€ video_watermark/                # è§†é¢‘æ°´å°ï¼ˆåŒæ¨¡å¼æ”¯æŒï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ video_watermark.py          # ç»Ÿä¸€è§†é¢‘æ¥å£ï¼ˆç”Ÿæˆ+ä¸Šä¼ ï¼‰
â”‚   â”‚   â”œâ”€â”€ hunyuan_video_generator.py  # HunyuanVideoæ–‡ç”Ÿè§†é¢‘
â”‚   â”‚   â”œâ”€â”€ model_manager.py            # æ¨¡å‹ç®¡ç†ï¼ˆç¦»çº¿ä¼˜å…ˆï¼‰
â”‚   â”‚   â”œâ”€â”€ videoseal_wrapper.py        # VideoSealæ°´å°ç®—æ³•
â”‚   â”‚   â””â”€â”€ utils.py                    # è§†é¢‘I/Oã€è½¬ç ã€æ€§èƒ½ç›‘æ§
â”‚   â””â”€â”€ utils/                          # é€šç”¨å·¥å…·å’Œæ¨¡å‹ç®¡ç†
â”œâ”€â”€ templates/                          # Webç•Œé¢æ¨¡æ¿
â”‚   â””â”€â”€ index.html                      # ç»Ÿä¸€Webæ¼”ç¤ºç•Œé¢
â”œâ”€â”€ demo_outputs/                       # æ¼”ç¤ºè¾“å‡ºç›®å½•
â”œâ”€â”€ demo_uploads/                       # æ¼”ç¤ºä¸Šä¼ ç›®å½•
â”œâ”€â”€ tests/                              # æµ‹è¯•å¥—ä»¶
â”‚   â”œâ”€â”€ test_unified_engine.py          # ç»Ÿä¸€å¼•æ“æµ‹è¯•
â”‚   â”œâ”€â”€ test_video_watermark_demo.py    # è§†é¢‘ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â””â”€â”€ test_audio_watermark.py         # éŸ³é¢‘æ°´å°æµ‹è¯•
â”œâ”€â”€ app.py                              # Flask Webåº”ç”¨åç«¯
â”œâ”€â”€ run_tests.py                        # ç»Ÿä¸€æµ‹è¯•è¿è¡Œå™¨
â”œâ”€â”€ audio_watermark_demo.py             # éŸ³é¢‘ç«¯åˆ°ç«¯æ¼”ç¤º
â””â”€â”€ models/                             # æœ¬åœ°æ¨¡å‹ç¼“å­˜ç›®å½•
```

å±‚çº§å…³ç³»ï¼ˆè‡ªé¡¶å‘ä¸‹ï¼‰ï¼š
- **Webåº”ç”¨å±‚**ï¼š`app.py`ï¼ˆFlask Webåç«¯ï¼‰+ `templates/index.html`ï¼ˆå‰ç«¯ç•Œé¢ï¼‰
- **åº”ç”¨å±‚**ï¼š`WatermarkTool`ï¼ˆæ¨èAPIå…¥å£ï¼Œæ”¯æŒåŒæ¨¡å¼ï¼‰
- **å¼•æ“å±‚**ï¼š`UnifiedWatermarkEngine`ï¼ˆç»Ÿä¸€è·¯ç”± text/image/audio/videoï¼‰
- **ç®—æ³•å±‚**ï¼šå„æ¨¡æ€æ°´å°å®ç°ï¼ˆæ”¯æŒAIç”Ÿæˆ+æ–‡ä»¶ä¸Šä¼ ï¼‰
- **å·¥å…·å±‚**ï¼š`utils`ã€å„æ¨¡æ€å†…éƒ¨çš„I/Oã€æ¨¡å‹ç®¡ç†ã€æ–‡ä»¶è½¬ç 

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

æœ¬å·¥å…·é‡‡ç”¨**åˆ†å±‚æ¨¡å—åŒ–æ¶æ„**ï¼Œæ”¯æŒå®Œæ•´çš„Webæ¼”ç¤ºå’ŒAPIè°ƒç”¨ï¼š

1. **Webæ¼”ç¤ºå±‚**ï¼š
   - Flask Webåº”ç”¨æä¾›REST APIå’Œæ–‡ä»¶æœåŠ¡
   - ç»Ÿä¸€å‰ç«¯ç•Œé¢æ”¯æŒåŒæ¨¡å¼åˆ‡æ¢å’Œå¯¹æ¯”æ˜¾ç¤º
   - å®æ—¶çŠ¶æ€åé¦ˆå’Œå¤šåª’ä½“æ’­æ”¾æ”¯æŒ

2. **ç”¨æˆ·æ¥å£å±‚**ï¼š
   - `WatermarkTool`æä¾›ç»Ÿä¸€APIæ¥å£
   - æ”¯æŒAIç”Ÿæˆå’Œæ–‡ä»¶ä¸Šä¼ ä¸¤ç§æ¨¡å¼
   - è‡ªåŠ¨ä¿å­˜åŸæ–‡ä»¶å’Œæ°´å°æ–‡ä»¶ç”¨äºå¯¹æ¯”

3. **æ ¸å¿ƒå¼•æ“å±‚**ï¼š
   - `UnifiedWatermarkEngine`ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ°´å°æ“ä½œ
   - æ‡’åŠ è½½å’Œç¦»çº¿ä¼˜å…ˆç­–ç•¥
   - åŒæ¨¡å¼å¤„ç†é€»è¾‘å’Œé”™è¯¯æ¢å¤

4. **ç®—æ³•å®ç°å±‚**ï¼š
   - å„æ¨¡æ€å…·ä½“ç®—æ³•å°è£…å’Œå®ç°
   - åç«¯é€‰æ‹©å’Œå‚æ•°é…ç½®ç®¡ç†
   - æ‰¹å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–

5. **é…ç½®å’Œå·¥å…·å±‚**ï¼š
   - YAMLé…ç½®æ–‡ä»¶ç®¡ç†
   - æ¨¡å‹ç¼“å­˜å’Œç¦»çº¿åŠ è½½
   - æ–‡ä»¶I/Oã€è½¬ç ã€è´¨é‡è¯„ä¼°

### 1. ç»Ÿä¸€æ°´å°å¼•æ“ï¼ˆUnifiedWatermarkEngineï¼‰- å·²å‡çº§æ”¯æŒåŒæ¨¡å¼

ä½ç½®ï¼š`src/unified/unified_engine.py`ï¼ˆé«˜å±‚å°è£…è¯·ä½¿ç”¨ `src/unified/watermark_tool.py`ï¼‰

æ ¸å¿ƒç‰¹æ€§ï¼š
- **åŒæ¨¡å¼æ”¯æŒ**ï¼šæ¯ä¸ªæ¨¡æ€éƒ½æ”¯æŒ"AIç”Ÿæˆå†…å®¹"å’Œ"ä¸Šä¼ ç°æœ‰æ–‡ä»¶"ä¸¤ç§å¤„ç†æ¨¡å¼
- **ç»Ÿä¸€æ¥å£**ï¼š`embed(prompt, message, modality, **kwargs)`å’Œ`extract(content, modality, **kwargs)`å››æ¨¡æ€ç»Ÿä¸€æ¥å£ï¼ŒæŒ‰éœ€æ‡’åŠ è½½æ¨¡å—
- **åŸæ–‡ä»¶ä¿å­˜**ï¼šAIç”Ÿæˆæ¨¡å¼å’Œæ–‡ä»¶ä¸Šä¼ æ¨¡å¼éƒ½è‡ªåŠ¨ä¿å­˜åŸæ–‡ä»¶å’Œæ°´å°æ–‡ä»¶ç”¨äºWebå¯¹æ¯”æ˜¾ç¤º
- **é»˜è®¤ç®—æ³•**ï¼š`text=credid`ï¼ˆä»…AIç”Ÿæˆï¼‰ï¼Œ`image=videoseal`ï¼Œ`audio=audioseal`ï¼Œ`video=hunyuan+videoseal`
- **ç¦»çº¿ä¼˜å…ˆ**ï¼šæ–‡æœ¬/å›¾åƒ/è§†é¢‘æ¨¡å‹ä¼˜å…ˆä»æœ¬åœ°ç¼“å­˜åŠ è½½ï¼Œé¿å…ç½‘ç»œä¾èµ–
- **é…ç½®é©±åŠ¨**ï¼šè¯»å–`config/default_config.yaml`å’Œ`config/text_config.yaml`ï¼Œæ”¯æŒè¿è¡Œæ—¶å‚æ•°è°ƒæ•´

### ğŸ¯ åŒæ¨¡å¼ä½¿ç”¨ç¤ºä¾‹ï¼ˆæ¨èé€šè¿‡ `WatermarkTool`ï¼‰:

```python
from src.unified.watermark_tool import WatermarkTool

tool = WatermarkTool()

# ===== AIç”Ÿæˆæ¨¡å¼ï¼ˆGenerate Modeï¼‰=====

# æ–‡æœ¬æ°´å°ï¼ˆä»…æ”¯æŒAIç”Ÿæˆæ¨¡å¼ï¼‰
watermarked_text = tool.embed("è¿™æ˜¯æµ‹è¯•æ–‡æœ¬", "wm_msg", 'text')
text_result = tool.extract(watermarked_text, 'text')
# è¿”å›: {'detected': True, 'message': 'wm_msg', 'confidence': 0.95}

# å›¾åƒAIç”Ÿæˆ + æ°´å°åµŒå…¥ï¼ˆVideoSealé»˜è®¤åç«¯ï¼‰
img = tool.embed("a cat under the sun", "hello_vs", 'image')
img_res = tool.extract(img, 'image', replicate=16, chunk_size=16)
# åç«¯è‡ªåŠ¨ä¿å­˜original_image.pngå’Œwatermarked_image.pngç”¨äºWebå¯¹æ¯”

# éŸ³é¢‘AIç”Ÿæˆï¼ˆBark TTSï¼‰+ æ°´å°åµŒå…¥
audio_out = tool.embed("Hello world", "hello_audio", 'audio', 
                      output_path="outputs/audio/generated.wav")
audio_res = tool.extract(audio_out, 'audio')
# åç«¯è‡ªåŠ¨ä¿å­˜original_audio.wavå’Œwatermarked_audio.wav

# è§†é¢‘AIç”Ÿæˆï¼ˆHunyuanVideoï¼‰+ æ°´å°åµŒå…¥
video_path = tool.embed("é˜³å…‰æ´’åœ¨æµ·é¢ä¸Š", "video_wm", 'video',
                       num_frames=49, height=720, width=1280)
video_res = tool.extract(video_path, 'video')
# åç«¯è‡ªåŠ¨ä¿å­˜original_video.mp4å’Œwatermarked_video.mp4


# ===== ä¸Šä¼ æ–‡ä»¶æ¨¡å¼ï¼ˆUpload File Modeï¼‰=====

# å›¾åƒæ–‡ä»¶æ°´å°åµŒå…¥
img_wm = tool.embed("watermark message", "file_msg", 'image',
                    image_input="/path/to/image.jpg")
img_file_res = tool.extract(img_wm, 'image')

# éŸ³é¢‘æ–‡ä»¶æ°´å°åµŒå…¥  
audio_wm = tool.embed("audio watermark", "audio_msg", 'audio',
                     audio_input="/path/to/audio.wav",
                     output_path="outputs/watermarked_audio.wav")
audio_file_res = tool.extract(audio_wm, 'audio')

# è§†é¢‘æ–‡ä»¶æ°´å°åµŒå…¥ï¼ˆè‡ªåŠ¨è½¬ç ä¸ºæµè§ˆå™¨å…¼å®¹æ ¼å¼ï¼‰
video_wm = tool.embed("video watermark", "video_msg", 'video',
                     video_input="/path/to/video.mp4")
video_file_res = tool.extract(video_wm, 'video')
```

### ğŸ“‹ é‡è¦å‚æ•°ä¸è¿”å›å€¼ï¼ˆåŒæ¨¡å¼æ”¯æŒï¼‰ï¼š

#### æ–‡æœ¬æ°´å°ï¼ˆä»…AIç”Ÿæˆæ¨¡å¼ï¼‰
- **æ¥å£**: `embed(prompt, message, 'text', model=None, tokenizer=None)` â†’ `str`
- **è¯´æ˜**: åŸºäºLLMçš„æ–‡æœ¬ç”Ÿæˆä¸æ°´å°åµŒå…¥ï¼Œè‡ªåŠ¨ä½¿ç”¨å¼•æ“ç¼“å­˜çš„æ¨¡å‹/åˆ†è¯å™¨
- **è¿”å›**: æ°´å°æ–‡æœ¬å­—ç¬¦ä¸²
- **æå–**: `extract(watermarked_text, 'text')` â†’ `{detected: bool, message: str, confidence: float}`

#### å›¾åƒæ°´å°ï¼ˆåŒæ¨¡å¼æ”¯æŒï¼‰
- **AIç”Ÿæˆæ¨¡å¼**: `embed(prompt, message, 'image', **kwargs)` â†’ `PIL.Image`  
- **ä¸Šä¼ æ–‡ä»¶æ¨¡å¼**: `embed(message, watermark_msg, 'image', image_input='/path/to/image.jpg')` â†’ `PIL.Image`
- **åç«¯é€‰æ‹©**: VideoSealï¼ˆé»˜è®¤ï¼‰æˆ–PRC-Watermarkï¼ˆé…ç½®algorithm: prcï¼‰
- **Webä¿å­˜**: è‡ªåŠ¨ä¿å­˜originalå’Œwatermarkedæ–‡ä»¶ç”¨äºå¯¹æ¯”æ˜¾ç¤º
- **æå–ä¼˜åŒ–**: æ”¯æŒ`replicate`å’Œ`chunk_size`å‚æ•°æå‡æ£€æµ‹ç½®ä¿¡åº¦

#### éŸ³é¢‘æ°´å°ï¼ˆåŒæ¨¡å¼æ”¯æŒï¼‰
- **AIç”Ÿæˆæ¨¡å¼**: `embed(tts_prompt, message, 'audio', output_path=None)` â†’ `torch.Tensor | str`
- **ä¸Šä¼ æ–‡ä»¶æ¨¡å¼**: `embed(message, watermark_msg, 'audio', audio_input='/path/to/audio.wav')` â†’ `torch.Tensor | str`
- **TTSé›†æˆ**: Barkæ–‡æœ¬è½¬è¯­éŸ³ï¼Œæ”¯æŒå¤šè¯­è¨€å’ŒéŸ³è‰²é€‰æ‹©
- **æ ¼å¼æ”¯æŒ**: WAV, MP3, FLAC, AAC, M4Aç­‰éŸ³é¢‘æ ¼å¼
- **Webä¿å­˜**: è‡ªåŠ¨ä¿å­˜originalå’ŒwatermarkedéŸ³é¢‘ç”¨äºå¯¹æ¯”æ’­æ”¾

#### è§†é¢‘æ°´å°ï¼ˆåŒæ¨¡å¼æ”¯æŒï¼‰  
- **AIç”Ÿæˆæ¨¡å¼**: `embed(prompt, message, 'video', num_frames=49, height=720, width=1280)` â†’ `str`
- **ä¸Šä¼ æ–‡ä»¶æ¨¡å¼**: `embed(message, watermark_msg, 'video', video_input='/path/to/video.mp4')` â†’ `str`
- **æŠ€æœ¯æ ˆ**: HunyuanVideoæ–‡ç”Ÿè§†é¢‘ + VideoSealæ°´å°ç®—æ³•
- **æµè§ˆå™¨å…¼å®¹**: è‡ªåŠ¨è½¬ç ä¸ºH.264+AAC+faststartæ ¼å¼ç¡®ä¿Webæ’­æ”¾
- **Webä¿å­˜**: è‡ªåŠ¨ä¿å­˜originalå’Œwatermarkedè§†é¢‘ç”¨äºå¯¹æ¯”æ’­æ”¾

#### ç»Ÿä¸€æå–æ¥å£
- **æ‰€æœ‰æ¨¡æ€**: `extract(content, modality, **kwargs)` â†’ `{detected: bool, message: str, confidence: float, metadata: dict}`
- **å¢å¼ºå‚æ•°**: å›¾åƒ/è§†é¢‘æ”¯æŒ`replicate`å’Œ`chunk_size`ï¼Œè§†é¢‘æ”¯æŒ`max_frames`é™åˆ¶

### ğŸ”§ ç¦»çº¿/ç¼“å­˜é…ç½®å»ºè®®ï¼š
- **ç¯å¢ƒå˜é‡**: è®¾ç½®`TRANSFORMERS_OFFLINE=1`ã€`HF_HUB_OFFLINE=1`å¼ºåˆ¶ç¦»çº¿åŠ è½½
- **æ¨¡å‹ç¼“å­˜**: å°†æ¨¡å‹æ”¾åœ¨`models/`ç›®å½•æˆ–é€šè¿‡`HF_HOME`/`HF_HUB_CACHE`æŒ‡å‘æœ¬åœ°ç¼“å­˜
- **æ–‡æœ¬æ¨¡å‹**: é»˜è®¤è¯»å–`config/text_config.yaml`çš„`model_name`ï¼Œç¼“å­˜æœªå‘½ä¸­æ—¶å›é€€`sshleifer/tiny-gpt2`
- **è§†é¢‘æ¨¡å‹**: HunyuanVideoä½¿ç”¨æœ¬åœ°å¿«ç…§ï¼Œé¿å…ç½‘ç»œä¸‹è½½ä¸ç¡®å®šæ€§

### 2. æ–‡æœ¬æ°´å°æ¨¡å— (CredID Algorithm) âœ… **å·²å®ç°**

**CredIDç®—æ³•åŸç†**ï¼š
- **å¤šä½æ°´å°**ï¼šæ”¯æŒåµŒå…¥å¤šæ®µä¿¡æ¯ï¼ˆå¦‚ç”¨æˆ·IDã€æ—¶é—´æˆ³ã€ç‰ˆæœ¬å·ç­‰ï¼‰
- **logitså¤„ç†**ï¼šåœ¨è¯­è¨€æ¨¡å‹çš„logitsè¾“å‡ºä¸Šè¿›è¡Œä¿®æ”¹ï¼Œå½±å“tokené€‰æ‹©æ¦‚ç‡
- **åŒæ¨¡å¼æ”¯æŒ**ï¼šLMæ¨¡å¼ï¼ˆé«˜è´¨é‡
- **å€™é€‰ä¼˜åŒ–**ï¼šæ”¯æŒå€™é€‰æ¶ˆæ¯åˆ—è¡¨çš„é™åˆ¶æœç´¢ï¼Œæå‡æ£€æµ‹æ•ˆç‡
- **æ™ºèƒ½åˆ†å‰²**ï¼šè‡ªåŠ¨å¤„ç†å¤æ‚æ¶ˆæ¯æ ¼å¼ï¼ˆå¦‚"log20250725143000"ï¼‰

**å®é™…å®ç°çš„æ ¸å¿ƒæ¶æ„**ï¼š

```python
# src/text_watermark/credid_watermark.py
import torch
import logging
from typing import Dict, Any, List, Optional, Union, Tuple
from transformers import PreTrainedModel, PreTrainedTokenizer, LogitsProcessorList

class CredIDWatermark:
    """
    CredIDæ–‡æœ¬æ°´å°ç®—æ³•ç»Ÿä¸€å°è£…
    
    âœ¨ æ ¸å¿ƒåŠŸèƒ½ç‰¹ç‚¹:
    1. æ”¯æŒå¤šç§æ¶ˆæ¯æ ¼å¼ (å­—ç¬¦ä¸²ã€æ•´æ•°åˆ—è¡¨ã€å­—ç¬¦ä¸²åˆ—è¡¨)
    2. åŒæ¨¡å¼è¿è¡Œ: LMæ¨¡å¼(é«˜è´¨é‡)
    3. æ™ºèƒ½å¤šæ®µæ¶ˆæ¯å¤„ç†å’Œè‡ªåŠ¨åˆ†å‰²
    4. å€™é€‰æ¶ˆæ¯ä¼˜åŒ–æœç´¢æœºåˆ¶
    5. å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œç½®ä¿¡åº¦è¯„ä¼°
    6. ç®€åŒ–çš„ä»£ç ç»“æ„ï¼Œå»é™¤å¤æ‚çš„æŒ‰ä½ç½®åˆ†ç»„é€»è¾‘
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        åˆå§‹åŒ–CredIDæ°´å°å¤„ç†å™¨
        
        Args:
            config: é…ç½®å­—å…¸ï¼Œå¿…é¡»åŒ…å«:
                - mode: 'lm' (é»˜è®¤'lm')
                - model_name: é¢„è®­ç»ƒæ¨¡å‹åç§°
                - lm_params: LMæ¨¡å¼å‚æ•°å­—å…¸
                - wm_params: æ°´å°å¤„ç†å‚æ•°å­—å…¸
                - å…¶ä»–ç”Ÿæˆå‚æ•° (max_new_tokens, num_beamsç­‰)
        """
        self.config = config
        self.mode = config.get('mode', 'lm')  # é»˜è®¤LMæ¨¡å¼
        self.model_name = config.get('model_name', 'huggyllama/llama-7b')
        
        # ç®—æ³•æ ¸å¿ƒå‚æ•°
        self.lm_params = config.get('lm_params', {})
        self.wm_params = config.get('wm_params', {})
        
        # å»¶è¿Ÿåˆå§‹åŒ–çš„ç»„ä»¶
        self.message_model = None
        self.tokenizer_ref = None
        
        logging.info(f"CredIDåˆå§‹åŒ–: æ¨¡å¼={self.mode}, æ¨¡å‹={self.model_name}")
```

**ğŸ”¹ æ ¸å¿ƒæ¥å£ 1: embed() - æ°´å°åµŒå…¥**

```python
    def embed(self, model: PreTrainedModel, tokenizer: PreTrainedTokenizer, 
              prompt: str, message: Union[str, List[int], List[str]], 
              segmentation_mode: str = 'auto') -> Dict[str, Any]:
        """
        ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: åœ¨æ–‡æœ¬ç”Ÿæˆè¿‡ç¨‹ä¸­åµŒå…¥æ°´å°
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. è®¾ç½®å¤„ç†å™¨ (å¦‚æœè¿˜æ²¡è®¾ç½®)
        2. å°†æ¶ˆæ¯è½¬æ¢ä¸ºCredIDå…¼å®¹çš„äºŒè¿›åˆ¶æ ¼å¼ (æ”¯æŒå¤šæ®µ)
        3. åˆ›å»ºåŒ…å«æ°´å°å¤„ç†å™¨çš„LogitsProcessorList
        4. ä½¿ç”¨model.generate()ç”Ÿæˆå¸¦æ°´å°æ–‡æœ¬
        5. è¿”å›å®Œæ•´ç»“æœå’Œè¯¦ç»†å…ƒæ•°æ®
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            model: HuggingFaceé¢„è®­ç»ƒè¯­è¨€æ¨¡å‹ (å¦‚Llama, GPTç­‰)
            tokenizer: å¯¹åº”çš„åˆ†è¯å™¨ï¼Œå¿…é¡»è®¾ç½®pad_token
            prompt: è¾“å…¥æç¤ºæ–‡æœ¬ï¼Œå¦‚ "Hello, today is"
            message: æ°´å°ä¿¡æ¯ï¼Œæ”¯æŒå¤šç§æ ¼å¼:
                - str: "hello" æˆ–å¤æ‚å­—ç¬¦ä¸² "log20250725143000"
                - List[int]: [123, 456, 789] 
                - List[str]: ["user", "2025", "admin"]
            segmentation_mode: æ¶ˆæ¯åˆ†å‰²æ¨¡å¼
                - 'auto': è‡ªåŠ¨åˆ¤æ–­æœ€ä½³åˆ†å‰²æ–¹å¼ (æ¨è)
                - 'smart': æ™ºèƒ½åˆ†å‰²ï¼Œå¦‚ "alibaba20250725" â†’ ["alibaba", "2025", "0725"]
                - 'whole': æ•´ä½“å¤„ç†
                - 'spaces': æŒ‰ç©ºæ ¼åˆ†å‰²
                
        ğŸ“¤ è¿”å›å€¼ç»“æ„:
            {
                'watermarked_text': str,      # ğŸ¯ å¸¦æ°´å°çš„ç”Ÿæˆæ–‡æœ¬
                'original_message': Any,      # åŸå§‹æ°´å°ä¿¡æ¯
                'binary_message': List[int],  # è½¬æ¢åçš„äºŒè¿›åˆ¶æ¶ˆæ¯åºåˆ—
                'prompt': str,                # è¾“å…¥æç¤º
                'success': bool,              # âœ…/âŒ æ˜¯å¦æˆåŠŸ
                'metadata': {                 # è¯¦ç»†å…ƒæ•°æ®
                    'mode': str,              # ä½¿ç”¨çš„æ¨¡å¼ ('lm')
                    'model_name': str,        # æ¨¡å‹åç§°
                    'input_length': int,      # è¾“å…¥tokené•¿åº¦
                    'output_length': int,     # è¾“å‡ºtokené•¿åº¦
                    'generation_config': dict,# ç”Ÿæˆé…ç½®å‚æ•°
                    'num_message_segments': int # æ¶ˆæ¯æ®µæ•°
                }
            }
            
        ğŸš¨ é”™è¯¯æƒ…å†µè¿”å›:
            {
                'watermarked_text': None,
                'success': False,
                'error': str                  # é”™è¯¯ä¿¡æ¯
            }
        """
```

**ğŸ”¹ æ ¸å¿ƒæ¥å£ 2: extract() - æ°´å°æå–**

```python
    def extract(self, watermarked_text: str, 
                model: Optional[PreTrainedModel] = None,
                tokenizer: Optional[PreTrainedTokenizer] = None,
                candidates_messages: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: ä»æ°´å°æ–‡æœ¬ä¸­æå–æ°´å°ä¿¡æ¯
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. æ£€æŸ¥æ¨¡å¼å’Œå‚æ•°æœ‰æ•ˆæ€§ (LMæ¨¡å¼éœ€è¦modelå’Œtokenizer)
        2. å€™é€‰æ¶ˆæ¯å¤„ç†: æ”¶é›†æ‰€æœ‰å€™é€‰æ¶ˆæ¯çš„æ‰€æœ‰ç¼–ç æ®µ (ç®€åŒ–ç­–ç•¥)
        3. ä½¿ç”¨CredIDè§£ç å™¨è¿›è¡Œç»Ÿè®¡æ£€æµ‹
        4. æ™ºèƒ½åŒ¹é…: å°†è§£ç ç»“æœä¸å€™é€‰æ¶ˆæ¯è¿›è¡Œåºåˆ—åŒ¹é…
        5. ç½®ä¿¡åº¦è®¡ç®—å’Œç»“æœéªŒè¯
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            watermarked_text: å¯èƒ½åŒ…å«æ°´å°çš„æ–‡æœ¬
            model: è¯­è¨€æ¨¡å‹ (LMæ¨¡å¼å¿…éœ€)
            tokenizer: åˆ†è¯å™¨ (LMæ¨¡å¼å¿…éœ€)
            candidates_messages: å€™é€‰æ¶ˆæ¯åˆ—è¡¨ï¼Œç”¨äºä¼˜åŒ–æœç´¢
                ğŸ¯ æ¨èä½¿ç”¨: å¯å¤§å¹…æå‡æ£€æµ‹ç²¾åº¦å’Œæ•ˆç‡
                ä¾‹å¦‚: ["log20250725143000", "user987654321", "admin2025"]
                
        ğŸ“¤ è¿”å›å€¼ç»“æ„:
            {
                'extracted_message': str,           # ğŸ¯ æå–çš„æ¶ˆæ¯
                'binary_message': List[int],        # è§£ç çš„äºŒè¿›åˆ¶æ¶ˆæ¯åºåˆ—
                'confidence': float,                # ğŸšï¸ ç½®ä¿¡åº¦ (0.0-1.0)
                'success': bool,                    # âœ…/âŒ æ˜¯å¦æˆåŠŸæå–
                'detailed_confidence': List,       # è¯¦ç»†ç½®ä¿¡åº¦ä¿¡æ¯
                'metadata': {
                    'mode': str,                    # æ£€æµ‹æ¨¡å¼
                    'text_length': int,             # æ–‡æœ¬é•¿åº¦
                    'num_decoded_segments': int,    # è§£ç æ®µæ•°
                    'detection_method': 'CredID',   # æ£€æµ‹æ–¹æ³•
                    'confidence_threshold': float,  # ç½®ä¿¡åº¦é˜ˆå€¼
                    'search_space': int,            # æœç´¢ç©ºé—´å¤§å°
                    'candidates_provided': bool     # æ˜¯å¦æä¾›å€™é€‰æ¶ˆæ¯
                }
            }
            
        ğŸš¨ å¤±è´¥æƒ…å†µè¿”å›:
            {
                'extracted_message': None,
                'confidence': 0.0,
                'success': False,
                'error': str                        # é”™è¯¯æˆ–"No watermark detected"
            }
        """
```

**ğŸ”§ æ ¸å¿ƒå†…éƒ¨æ–¹æ³•**

```python
    # === æ¶ˆæ¯å¤„ç†æ–¹æ³• ===
    def _message_to_binary(self, message: Union[str, List[int], List[str]], 
                          segmentation_mode: str = 'auto') -> List[int]:
        """å°†å¤šç§æ ¼å¼çš„æ¶ˆæ¯è½¬æ¢ä¸ºCredIDå…¼å®¹çš„æ•´æ•°åºåˆ—"""
        
    def _binary_to_message(self, binary: List[int]) -> Union[str, List[str]]:
        """å°†è§£ç çš„æ•´æ•°åºåˆ—è½¬æ¢å›åŸå§‹æ¶ˆæ¯æ ¼å¼"""
        
    # === æ™ºèƒ½åŒ¹é…æ–¹æ³• ===  
    def _match_decoded_with_candidates(self, decoded_messages: List[int], 
                                     candidates_messages: List[str]) -> Tuple[str, float]:
        """å°†è§£ç ç»“æœä¸å€™é€‰æ¶ˆæ¯è¿›è¡Œæ™ºèƒ½åŒ¹é… (ç®€åŒ–ç‰ˆæœ¬)"""
        
    def _calculate_sequence_match(self, decoded: List[int], candidate: List[int]) -> float:
        """è®¡ç®—ä¸¤ä¸ªåºåˆ—çš„åŒ¹é…åº¦åˆ†æ•°"""
        
    # === å­—ç¬¦ä¸²åˆ†å‰²æ–¹æ³• ===
    def _smart_segment_string(self, text: str) -> List[str]:
        """æ™ºèƒ½åˆ†å‰²å­—ç¬¦ä¸²ï¼Œæ”¯æŒå¤æ‚æ ¼å¼å¦‚'log20250725143000'"""
```

**âš™ï¸ é…ç½®å‚æ•°è¯¦è§£**

```yaml
# config/text_config.yaml - å®Œæ•´é…ç½®ç¤ºä¾‹
method: "CredID"
model_name: "huggyllama/llama-7b"          
mode: "lm"                                 # 'lm'(é«˜è´¨é‡) /
device: "auto"                             

# === ç”Ÿæˆå‚æ•° ===
max_new_tokens: 110                        
num_beams: 4                               
do_sample: true                            
temperature: 0.7                           
top_p: 0.9                                
top_k: 50                                 

# === CredID LMæ¨¡å¼æ ¸å¿ƒå‚æ•° ===
lm_params:
  delta: 1.5                              # logitsä¿®æ”¹å¼ºåº¦ (å…³é”®å‚æ•°)
  prefix_len: 10                          # å‰ç¼€ä¿æŠ¤é•¿åº¦
  message_len: 10                         # æ¯æ®µæ¶ˆæ¯çš„äºŒè¿›åˆ¶é•¿åº¦
  seed: 42                                # éšæœºç§å­
  topk: -1                               # LM top-ké™åˆ¶
  permutation_num: 50                     # éšæœºæ’åˆ—æ•°
  hash_prefix_len: 1                      # å“ˆå¸Œå‰ç¼€é•¿åº¦
  shifts: [21, 24, 3, 8, 14,2, 4, 28, 31, 3, 8, 14, 2, 4, 28, 16, 7, 19, 25, 11, 33, 1, 0, 8, 34]

# === æ°´å°å¤„ç†å‚æ•° ===
wm_params:
  encode_ratio: 4                         # ç¼–ç æ¯”ç‡ (æ¯æ¶ˆæ¯ä½å¯¹åº”çš„tokenæ•°)
  seed: 42                                
  strategy: "vanilla"                     # 'vanilla'/'max_confidence'
  max_confidence: 0.5                     
  top_k: 1000                            

# === è§£ç é…ç½® ===
decode_batch_size: 16                      
disable_tqdm: false                        
confidence_threshold: 0.6                  # æˆåŠŸæ£€æµ‹çš„ç½®ä¿¡åº¦é˜ˆå€¼
```

**ğŸš€ å®é™…ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ**

```python
# === å®Œæ•´ä½¿ç”¨ç¤ºä¾‹ ===
from src.text_watermark.credid_watermark import CredIDWatermark
from transformers import AutoModelForCausalLM, AutoTokenizer
import yaml

# 1. åˆå§‹åŒ–ç³»ç»Ÿ
with open('config/text_config.yaml', 'r') as f:
    config = yaml.safe_load(f)

model = AutoModelForCausalLM.from_pretrained("huggyllama/llama-7b")
tokenizer = AutoTokenizer.from_pretrained("huggyllama/llama-7b")
if tokenizer.pad_token is None:
    tokenizer.pad_token = tokenizer.eos_token

watermark = CredIDWatermark(config)

# 2. ğŸ¯ å•ä¸€æ¶ˆæ¯å¤„ç†
result = watermark.embed(model, tokenizer, "Hello, today is", "tech")
if result['success']:
    print(f"âœ… ç”Ÿæˆæ–‡æœ¬: {result['watermarked_text']}")
    
    # åŸºç¡€æå–
    extracted = watermark.extract(result['watermarked_text'], model, tokenizer)
    print(f"ğŸ“¤ æå–ç»“æœ: {extracted['extracted_message']} (ç½®ä¿¡åº¦: {extracted['confidence']:.3f})")

# 3. ğŸ¯ å¤æ‚æ¶ˆæ¯å¤„ç†
complex_messages = [
    ("ç³»ç»Ÿæ—¥å¿—", "log20250725143000"),
    ("ç”¨æˆ·ä¿¡æ¯", "alibaba20250725"),
    ("ç®¡ç†è´¦æˆ·", ["admin", "2025", "secure"])
]

for desc, message in complex_messages:
    result = watermark.embed(model, tokenizer, f"Entry: ", message)
    if result['success']:
        print(f"\n=== {desc} ===")
        print(f"æ¶ˆæ¯: {message}")
        print(f"ç”Ÿæˆ: {result['watermarked_text']}")
        
        # ğŸ¯ å€™é€‰ä¼˜åŒ–æå–
        candidates = ["log20250725143000", "alibaba20250725", "admin2025secure", "tech", "hello"]
        extracted = watermark.extract(
            result['watermarked_text'], 
            model, tokenizer, 
            candidates_messages=candidates
        )
        
        success_icon = "âœ…" if extracted['success'] else "âŒ"
        print(f"{success_icon} æå–: {extracted['extracted_message']} (ç½®ä¿¡åº¦: {extracted['confidence']:.3f})")

# 4. ğŸ¯ æ‰¹é‡å¤„ç†æ€§èƒ½æµ‹è¯•
import time

test_messages = ["hello", "tech2025", "user123", "log20250725143000"]
batch_start = time.time()

batch_results = []
for i, msg in enumerate(test_messages):
    embed_result = watermark.embed(model, tokenizer, f"Test {i}: ", msg)
    if embed_result['success']:
        extract_result = watermark.extract(embed_result['watermarked_text'], model, tokenizer)
        batch_results.append({
            'original': msg,
            'extracted': extract_result['extracted_message'],
            'confidence': extract_result['confidence'],
            'success': extract_result['success']
        })

batch_time = time.time() - batch_start
print(f"\nâ±ï¸ æ‰¹é‡å¤„ç†({len(test_messages)}æ¡): {batch_time:.2f}ç§’")

# 5. ğŸ¯ é”™è¯¯å¤„ç†ç¤ºä¾‹
try:
    # æ¨¡æ‹Ÿé”™è¯¯æƒ…å†µ
    error_result = watermark.extract("This text has no watermark", model, tokenizer)
    if not error_result['success']:
        print(f"âŒ æ£€æµ‹å¤±è´¥: {error_result.get('error', 'No watermark detected')}")
except Exception as e:
    print(f"ğŸš¨ å¼‚å¸¸å¤„ç†: {e}")
```

**ğŸ“Š æ€§èƒ½å’Œç‰¹ç‚¹æ€»ç»“**

| ç‰¹æ€§ | æè¿° | ä¼˜åŠ¿ |
|------|------|------|
| **å¤šæ¶ˆæ¯æ ¼å¼** | æ”¯æŒå­—ç¬¦ä¸²ã€åˆ—è¡¨ã€å¤æ‚æ ¼å¼ | çµæ´»æ€§é«˜ï¼Œé€‚åº”ä¸åŒåœºæ™¯ |
| **å€™é€‰ä¼˜åŒ–** | é™åˆ¶æœç´¢ç©ºé—´æå‡æ•ˆç‡ | å¤§å¹…æå‡æ£€æµ‹ç²¾åº¦ |
| **æ™ºèƒ½åˆ†å‰²** | è‡ªåŠ¨å¤„ç†å¤æ‚æ¶ˆæ¯æ ¼å¼ | æ— éœ€æ‰‹åŠ¨é¢„å¤„ç† |
| **ç®€åŒ–æ¶æ„** | å»é™¤å¤æ‚çš„æŒ‰ä½ç½®åˆ†ç»„é€»è¾‘ | ä»£ç æ›´æ¸…æ™°ï¼Œç»´æŠ¤æ€§å¥½ |
| **é”™è¯¯å¤„ç†** | å®Œæ•´çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ | ç”Ÿäº§ç¯å¢ƒå¯é æ€§é«˜ |
| **æ€§èƒ½ç›‘æ§** | å†…ç½®æ—¶é—´å’Œèµ„æºä½¿ç”¨ç»Ÿè®¡ | ä¾¿äºæ€§èƒ½è°ƒä¼˜ |


## ğŸ†• 2025-08 æ›´æ–°æ‘˜è¦ï¼ˆdiffusers==0.34 å…¼å®¹ + VideoSeal å›¾åƒåç«¯ï¼‰

### åŠ¨æœº
- ä¸ºå…¼å®¹æ–°çš„è§†é¢‘æ¨¡å‹ï¼ˆHunyuanï¼‰ï¼Œç¯å¢ƒå‡çº§è‡³ `diffusers==0.34`ã€‚è¯¥ç‰ˆæœ¬å¯¹è‡ªå®šä¹‰ç®¡çº¿/æ¨¡å—æ³¨å†Œæœ‰å˜æ›´ï¼Œæ—§ PRC è·¯å¾„æ˜“å—å½±å“ã€‚å› æ­¤æ–°å¢ VideoSeal ä½œä¸ºå›¾åƒæ°´å°çš„ç¬¬äºŒåç«¯ï¼Œå¹¶å°†ç›¸å…³åŠ è½½æ”¹é€ ä¸º"æ‡’åŠ è½½ + ç¦»çº¿ä¼˜å…ˆ"ã€‚

### ä¸»è¦æ”¹åŠ¨
- å›¾åƒæ°´å°æ–°å¢åç«¯ï¼š`videoseal`
  - æ–°æ–‡ä»¶ `src/image_watermark/videoseal_image_watermark.py`ï¼šå°†å•å›¾å½“ä½œå•å¸§è§†é¢‘ï¼Œå¤ç”¨ `src/video_watermark/videoseal_wrapper.py` çš„ `embed/detect`ï¼Œå¯¹å›¾åƒæä¾›æ—  Diffusers ä¾èµ–çš„ç¨³å¥åµŒå…¥/æå–ã€‚
  - `src/image_watermark/image_watermark.py`ï¼š
    - æ‡’åŠ è½½å…·ä½“ç®—æ³•å¤„ç†å™¨ï¼Œé¿å…åœ¨æ„é€ é˜¶æ®µåŠ è½½æ— å…³ä¾èµ–ã€‚
    - æ”¯æŒ `algorithm: videoseal`ï¼Œå¹¶åœ¨æ— å›¾åƒè¾“å…¥æ—¶ï¼Œå…ˆç”¨ Stable Diffusion ç”Ÿæˆï¼Œå†è°ƒç”¨ VideoSeal åµŒå…¥ã€‚
  - `src/unified/watermark_tool.py`ï¼š`get_supported_algorithms()['image']` å¢åŠ  `videoseal`ã€‚
  - æ£€æµ‹å¢å¼ºï¼š`extract(..., replicate=N, chunk_size=N)` æ”¯æŒå°†å•å¸§å¤åˆ¶ä¸ºå¤šå¸§åšå‡å€¼ï¼Œæ˜¾è‘—æå‡è¯»å‡ºç¨³å®šæ€§ä¸ç½®ä¿¡åº¦ã€‚

- ç¦»çº¿åŠ è½½ï¼ˆStable Diffusionï¼‰
  - `src/utils/model_manager.py`ï¼š
    - å¼ºåˆ¶ `TRANSFORMERS_OFFLINE/DIFFUSERS_OFFLINE/HF_HUB_OFFLINE`ã€‚
    - è§£æ/ä¼˜å…ˆè¿”å› HF Hub æœ¬åœ°ç¼“å­˜ç›®å½• `.../hub/models--stabilityai--stable-diffusion-2-1-base`ï¼Œä¸ PRC è·¯å¾„ä¸€è‡´ï¼›`from_pretrained(local_files_only=True)` ç¦»çº¿è§£æ refsã€‚

- æ–‡æœ¬æ°´å°ï¼ˆCredIDï¼‰ç¦»çº¿åŠ è½½
  - `test_complex_messages_real.py`ï¼š
    - å¼ºåˆ¶ç¦»çº¿å˜é‡ã€‚
    - `AutoTokenizer/AutoModelForCausalLM.from_pretrained(..., local_files_only=True, cache_dir=...)`ã€‚
    - è‡ªåŠ¨æ¢æµ‹ç¼“å­˜ç›®å½•æˆ–é€šè¿‡é…ç½® `hf_cache_dir` æŒ‡å®šã€‚

- å¯¼å…¥ä¸æµ‹è¯•
  - ç»Ÿä¸€ `src.*` ç»å¯¹å¯¼å…¥é£æ ¼ï¼Œè„šæœ¬ä»é¡¹ç›®æ ¹è¿è¡Œç¨³å®šã€‚
  - `tests/conftest.py` å°† `src/` æ³¨å…¥ `sys.path`ï¼Œæµ‹è¯•æ—¶ `unified.*` å¯å¯¼å…¥ã€‚
  - æ–°å¢ï¼š
    - `tests/test_image_videoseal.py`ï¼ˆæœ€å°éªŒè¯ï¼‰
    - æ ¹çº§ `test_image_videoseal_root.py`ï¼šå¯ç›´æ¥ `python` æ¼”ç¤º
      - `--mode pil`ï¼šç°æœ‰å›¾åƒåµŒå…¥/æå–
      - `--mode gen`ï¼šç”Ÿæˆâ†’åµŒå…¥â†’æå–ï¼ˆå®Œå…¨ç¦»çº¿ï¼Œéœ€æœ¬åœ° SD æƒé‡ï¼‰

### ä½¿ç”¨ä¸è°ƒå‚å»ºè®®ï¼ˆVideoSeal å›¾åƒæ°´å°ï¼‰
- é…ç½®ï¼ˆç¤ºä¾‹ï¼‰ï¼š
```yaml
image_watermark:
  algorithm: videoseal
  model_name: stabilityai/stable-diffusion-2-1-base
  resolution: 512
  num_inference_steps: 30
  lowres_attenuation: true
  device: cuda
```
- ç”Ÿæˆ â†’ åµŒå…¥ â†’ æå–ï¼š
```python
from src.unified.watermark_tool import WatermarkTool
tool = WatermarkTool()
tool.set_algorithm('image', 'videoseal')
img = tool.generate_image_with_watermark(prompt='a cat', message='hello_videoseal')
res = tool.extract_image_watermark(img, replicate=16, chunk_size=16)
```
- CLI æ¼”ç¤ºï¼š
```bash
python test_image_videoseal_root.py --mode pil  --device cuda
python test_image_videoseal_root.py --mode gen  --device cuda --resolution 512 --steps 30
```

### æå‡æ£€æµ‹ç½®ä¿¡åº¦
- ç”Ÿæˆä¾§ï¼šæé«˜ `resolution`/`num_inference_steps`ï¼›ç®€åŒ– promptï¼›ä½¿ç”¨ GPUã€‚
- æ£€æµ‹ä¾§ï¼š`replicate` è®¾ä¸º 8~32ï¼Œå¹¶ä¸ `chunk_size` å¯¹é½ï¼Œä½¿ç”¨å¤šå¸§å‡å€¼ï¼›å¯¹å•å›¾å°¤å…¶æœ‰æ•ˆã€‚

### 4. éŸ³é¢‘æ°´å°æ¨¡å— (AudioSeal Algorithm) âœ… **å·²å®Œæˆå®ç°**

**AudioSealç®—æ³•åŸç†ä¸å®ç°çŠ¶æ€**ï¼š
- **Meta AudioSealç®—æ³•**ï¼šåŸºäºæ·±åº¦å­¦ä¹ çš„é²æ£’éŸ³é¢‘æ°´å°æŠ€æœ¯ï¼Œå®Œæ•´Pythonå°è£…ï¼Œç”Ÿäº§ç¯å¢ƒå°±ç»ª
- **16ä½æ¶ˆæ¯ç¼–ç ç³»ç»Ÿ**ï¼šä½¿ç”¨SHA256å“ˆå¸Œç¡®ä¿ç¼–ç ä¸€è‡´æ€§ï¼Œæ”¯æŒå­—ç¬¦ä¸²åˆ°äºŒè¿›åˆ¶çš„å¯é è½¬æ¢  
- **é«˜ä¿çœŸåµŒå…¥**ï¼šSNR>40dBï¼ˆå®æµ‹44.45dBï¼‰ï¼Œå¬è§‰è´¨é‡å‡ ä¹æ— æŸå¤±ï¼Œ100%æ£€æµ‹æˆåŠŸç‡
- **è®¾å¤‡è‡ªé€‚åº”ä¼˜åŒ–**ï¼šæ”¯æŒCPU/CUDAè‡ªåŠ¨åˆ‡æ¢å’Œè®¾å¤‡å¼ é‡ç®¡ç†ï¼Œä¿®å¤è®¾å¤‡ä¸åŒ¹é…é—®é¢˜
- **é«˜æ•ˆæ‰¹å¤„ç†**ï¼š3ä¸ªéŸ³é¢‘2.8ç§’ï¼Œå¹¶è¡Œå¤„ç†ä¼˜åŒ–ï¼Œæ”¯æŒå¤§è§„æ¨¡åº”ç”¨

**å·²å®ç°çš„æ ¸å¿ƒæ¶æ„ä¸æ€§èƒ½**ï¼š

```python
# src/audio_watermark/audio_watermark.py - å®Œæ•´å®ç°
import torch
import logging
from typing import Dict, Any, List, Optional, Union, Tuple
from pathlib import Path

class AudioWatermark:
    """
    AudioSealéŸ³é¢‘æ°´å°ç®—æ³•ç»Ÿä¸€å°è£… - ç”Ÿäº§ç¯å¢ƒå°±ç»ª
    
    âœ… å·²å®Œæˆæ ¸å¿ƒåŠŸèƒ½:
    1. Meta AudioSealå®Œæ•´é›†æˆ - 100%æ£€æµ‹æˆåŠŸç‡ï¼ŒSNR 44.45dB
    2. Bark TTSç«¯åˆ°ç«¯æµç¨‹ - æ”¯æŒå¤šè¯­è¨€ï¼ˆä¸­è‹±æ–‡ï¼‰é«˜è´¨é‡è¯­éŸ³ç”Ÿæˆ
    3. å¤šæ ¼å¼éŸ³é¢‘æ”¯æŒ - WAV/MP3/FLACç­‰ï¼Œå®Œæ•´I/Oå¤„ç†
    4. è®¾å¤‡è‡ªé€‚åº”ä¼˜åŒ– - CPU/CUDAè‡ªåŠ¨åˆ‡æ¢ï¼Œå†…å­˜ä¼˜åŒ–ï¼Œè®¾å¤‡ä¸€è‡´æ€§ä¿®å¤  
    5. é«˜æ•ˆæ‰¹å¤„ç† - 3ä¸ªéŸ³é¢‘2.8ç§’ï¼Œå¹¶è¡Œå¤„ç†ä¼˜åŒ–
    6. å®Œæ•´è´¨é‡è¯„ä¼° - SNR/MSE/ç›¸å…³æ€§æŒ‡æ ‡ï¼Œå™ªå£°é²æ£’æ€§æµ‹è¯•
    7. æŠ€æœ¯é—®é¢˜ä¿®å¤ - 3Då¼ é‡ç»´åº¦å¤„ç†ï¼Œè®¾å¤‡åŒ¹é…ï¼ŒBarkå¯¼å…¥æ£€æµ‹
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        åˆå§‹åŒ–AudioSealéŸ³é¢‘æ°´å°å¤„ç†å™¨
        
        Args:
            config: é…ç½®å­—å…¸ï¼ŒåŒ…å«:
                - algorithm: 'audioseal' (é»˜è®¤)
                - device: 'cuda', 'cpu', æˆ– 'auto'
                - nbits: æ¶ˆæ¯ä½æ•° (é»˜è®¤16)
                - sample_rate: é‡‡æ ·ç‡ (é»˜è®¤16000)
                - bark_config: Bark TTSé…ç½®
        """
        self.config = config
        self.algorithm = config.get('algorithm', 'audioseal')
        self.device = config.get('device', 'auto')
        self.nbits = config.get('nbits', 16)
        self.sample_rate = config.get('sample_rate', 16000)
        
        # å»¶è¿Ÿåˆå§‹åŒ–çš„ç»„ä»¶
        self.audioseal_wrapper = None
        self.bark_generator = None
        
        logging.info(f"AudioWatermarkåˆå§‹åŒ–: ç®—æ³•={self.algorithm}, è®¾å¤‡={self.device}")
```

**ğŸ”¹ æ ¸å¿ƒæ¥å£ 1: embed_watermark() - éŸ³é¢‘æ°´å°åµŒå…¥**

```python
    def embed_watermark(self, 
                       audio: Union[str, torch.Tensor, Path], 
                       message: str,
                       input_sample_rate: Optional[int] = None,
                       alpha: float = 1.0,
                       output_path: Optional[str] = None) -> Union[torch.Tensor, str]:
        """
        ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: åœ¨éŸ³é¢‘ä¸­åµŒå…¥AudioSealæ°´å°
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. éŸ³é¢‘åŠ è½½å’Œé¢„å¤„ç† (é‡é‡‡æ ·åˆ°16kHzï¼Œæ ¼å¼è½¬æ¢)
        2. æ¶ˆæ¯ç¼–ç ä¸º16ä½äºŒè¿›åˆ¶åºåˆ— (SHA256å“ˆå¸Œ)
        3. ä½¿ç”¨AudioSealç”Ÿæˆå™¨è¿›è¡Œæ°´å°åµŒå…¥
        4. åå¤„ç†å’Œè¾“å‡º (ä¿å­˜æ–‡ä»¶æˆ–è¿”å›å¼ é‡)
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            audio: è¾“å…¥éŸ³é¢‘ï¼Œæ”¯æŒå¤šç§æ ¼å¼:
                - str/Path: éŸ³é¢‘æ–‡ä»¶è·¯å¾„ (WAV, MP3, FLACç­‰)
                - torch.Tensor: éŸ³é¢‘å¼ é‡ (1, samples) æˆ– (samples,)
            message: è¦åµŒå…¥çš„å­—ç¬¦ä¸²æ¶ˆæ¯ï¼Œå¦‚ "user123", "2025_watermark"
            input_sample_rate: è¾“å…¥éŸ³é¢‘é‡‡æ ·ç‡ (ä»æ–‡ä»¶æ¨æ–­æˆ–æ‰‹åŠ¨æŒ‡å®š)
            alpha: æ°´å°å¼ºåº¦ (0.0-2.0ï¼Œé»˜è®¤1.0ï¼Œè¶Šé«˜æ°´å°è¶Šå¼ºä½†å¤±çœŸè¶Šå¤§)
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„ (å¯é€‰ï¼Œæä¾›åˆ™ä¿å­˜æ–‡ä»¶)
            
        ğŸ“¤ è¿”å›å€¼:
            - å¦‚æœæä¾›output_path: è¿”å›ä¿å­˜çš„æ–‡ä»¶è·¯å¾„(str)
            - å¦åˆ™: è¿”å›å¸¦æ°´å°çš„éŸ³é¢‘å¼ é‡(torch.Tensor)
            
        ğŸš¨ é”™è¯¯æƒ…å†µ:
            æŠ›å‡ºRuntimeErrorå¼‚å¸¸ï¼ŒåŒ…å«è¯¦ç»†é”™è¯¯ä¿¡æ¯
        """
        self._ensure_audioseal()
        
        # å¤„ç†ä¸åŒè¾“å…¥æ ¼å¼
        if isinstance(audio, (str, Path)):
            from .utils import AudioIOUtils
            audio_tensor, sr = AudioIOUtils.load_audio(
                str(audio), 
                target_sample_rate=self.sample_rate
            )
        else:
            audio_tensor = audio
            sr = input_sample_rate or self.sample_rate
        
        # åµŒå…¥æ°´å°
        watermarked = self.audioseal_wrapper.embed(
            audio_tensor, message, sr, alpha
        )
        
        if output_path:
            from .utils import AudioIOUtils
            AudioIOUtils.save_audio(watermarked, output_path, self.sample_rate)
            return output_path
        else:
            return watermarked
```

**ğŸ”¹ æ ¸å¿ƒæ¥å£ 2: extract_watermark() - éŸ³é¢‘æ°´å°æå–**

```python
    def extract_watermark(self, 
                         watermarked_audio: Union[str, torch.Tensor, Path],
                         input_sample_rate: Optional[int] = None,
                         detection_threshold: float = 0.5,
                         message_threshold: float = 0.5) -> Dict[str, Any]:
        """
        ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: ä»éŸ³é¢‘ä¸­æå–AudioSealæ°´å°ä¿¡æ¯
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. éŸ³é¢‘åŠ è½½å’Œé¢„å¤„ç†
        2. ä½¿ç”¨AudioSealæ£€æµ‹å™¨è¿›è¡Œæ°´å°æ£€æµ‹
        3. æ¶ˆæ¯è§£ç å’ŒåŒ¹é… (ä¸å†å²æ¶ˆæ¯åº“åŒ¹é…)
        4. ç½®ä¿¡åº¦è®¡ç®—å’Œç»“æœéªŒè¯
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            watermarked_audio: å¯èƒ½åŒ…å«æ°´å°çš„éŸ³é¢‘
            input_sample_rate: è¾“å…¥éŸ³é¢‘é‡‡æ ·ç‡
            detection_threshold: æ£€æµ‹é˜ˆå€¼ (0.0-1.0ï¼Œé»˜è®¤0.5)
            message_threshold: æ¶ˆæ¯è§£ç é˜ˆå€¼ (0.0-1.0ï¼Œé»˜è®¤0.5)
            
        ğŸ“¤ è¿”å›å€¼ç»“æ„:
            {
                'detected': bool,               # ğŸ¯ æ˜¯å¦æ£€æµ‹åˆ°æ°´å°
                'message': str,                 # ğŸ“¤ è§£ç çš„æ¶ˆæ¯ (æ£€æµ‹æˆåŠŸæ—¶)
                'confidence': float,            # ğŸšï¸ æ£€æµ‹ç½®ä¿¡åº¦ (0.0-1.0)
                'raw_bits': torch.Tensor,      # åŸå§‹äºŒè¿›åˆ¶è§£ç ç»“æœ
                'processing_time': float,       # å¤„ç†è€—æ—¶ (ç§’)
                'metadata': {                   # è¯¦ç»†å…ƒæ•°æ®
                    'algorithm': 'audioseal',   # ç®—æ³•åç§°
                    'sample_rate': int,         # é‡‡æ ·ç‡
                    'audio_length': float,      # éŸ³é¢‘æ—¶é•¿
                    'detection_threshold': float,
                    'message_threshold': float
                }
            }
            
        ğŸš¨ å¤±è´¥æƒ…å†µè¿”å›:
            {
                'detected': False,
                'message': '',
                'confidence': 0.0,
                'error': str                    # é”™è¯¯ä¿¡æ¯
            }
        """
        self._ensure_audioseal()
        
        # å¤„ç†è¾“å…¥éŸ³é¢‘
        if isinstance(watermarked_audio, (str, Path)):
            from .utils import AudioIOUtils
            audio_tensor, sr = AudioIOUtils.load_audio(
                str(watermarked_audio), 
                target_sample_rate=self.sample_rate
            )
        else:
            audio_tensor = watermarked_audio
            sr = input_sample_rate or self.sample_rate
        
        # æå–æ°´å°
        result = self.audioseal_wrapper.extract(
            audio_tensor, sr, detection_threshold, message_threshold
        )
        
        return result
```

**ğŸ”¹ é«˜çº§æ¥å£: generate_audio_with_watermark() - æ–‡æœ¬è½¬è¯­éŸ³+æ°´å°**

```python
    def generate_audio_with_watermark(self,
                                     prompt: str,
                                     message: str,
                                     voice_preset: Optional[str] = None,
                                     temperature: float = 0.8,
                                     seed: Optional[int] = None,
                                     alpha: float = 1.0,
                                     output_path: Optional[str] = None) -> Union[torch.Tensor, str]:
        """
        ğŸ¯ é«˜çº§åŠŸèƒ½: æ–‡æœ¬è½¬è¯­éŸ³å¹¶åµŒå…¥æ°´å° (éœ€è¦Bark)
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. ä½¿ç”¨Bark TTSç”Ÿæˆé«˜è´¨é‡è¯­éŸ³
        2. è‡ªåŠ¨åµŒå…¥AudioSealæ°´å°
        3. è¿”å›å¸¦æ°´å°çš„è¯­éŸ³éŸ³é¢‘
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            prompt: è¦è½¬æ¢çš„æ–‡æœ¬ï¼Œå¦‚ "Hello, this is a test message"
            message: è¦åµŒå…¥çš„æ°´å°ä¿¡æ¯
            voice_preset: è¯­éŸ³é¢„è®¾ï¼Œå¦‚ "v2/en_speaker_6", "v2/zh_speaker_0"
            temperature: ç”Ÿæˆæ¸©åº¦ (0.0-1.0ï¼Œæ§åˆ¶éšæœºæ€§)
            seed: éšæœºç§å­ (å¯é‡ç°ç”Ÿæˆ)
            alpha: æ°´å°å¼ºåº¦
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„ (å¯é€‰)
            
        ğŸ“¤ è¿”å›å€¼:
            - å¦‚æœæä¾›output_path: è¿”å›ä¿å­˜çš„æ–‡ä»¶è·¯å¾„
            - å¦åˆ™: è¿”å›å¸¦æ°´å°çš„éŸ³é¢‘å¼ é‡
            
        ğŸš¨ ä¾èµ–è¦æ±‚:
            éœ€è¦å®‰è£…Bark: pip install git+https://github.com/suno-ai/bark.git
        """
        self._ensure_bark()
        
        # ä½¿ç”¨Barkç”Ÿæˆè¯­éŸ³
        generated_audio = self.bark_generator.generate_audio(
            prompt, voice_preset, temperature, seed
        )
        
        # åµŒå…¥æ°´å°
        watermarked_audio = self.audioseal_wrapper.embed(
            generated_audio, message, self.sample_rate, alpha
        )
        
        if output_path:
            from .utils import AudioIOUtils
            AudioIOUtils.save_audio(watermarked_audio, output_path, self.sample_rate)
            return output_path
        else:
            return watermarked_audio
```

**ğŸ”§ æ ¸å¿ƒå†…éƒ¨æ–¹æ³•**

```python
    # === è´¨é‡è¯„ä¼°æ–¹æ³• ===
    def evaluate_quality(self, original: torch.Tensor, 
                        watermarked: torch.Tensor) -> Dict[str, float]:
        """è®¡ç®—éŸ³é¢‘è´¨é‡æŒ‡æ ‡ (SNR, MSE, ç›¸å…³æ€§)"""
        
    def batch_embed(self, audios: List, messages: List[str]) -> List:
        """æ‰¹é‡éŸ³é¢‘æ°´å°åµŒå…¥"""
        
    def batch_extract(self, watermarked_audios: List) -> List[Dict]:
        """æ‰¹é‡éŸ³é¢‘æ°´å°æå–"""
        
    # === ç»„ä»¶åˆå§‹åŒ–æ–¹æ³• ===
    def _ensure_audioseal(self):
        """ç¡®ä¿AudioSealå°è£…å™¨å·²åˆå§‹åŒ–"""
        
    def _ensure_bark(self):
        """ç¡®ä¿Barkç”Ÿæˆå™¨å·²åˆå§‹åŒ– (å¦‚æœéœ€è¦TTSåŠŸèƒ½)"""
```

**âš™ï¸ é…ç½®å‚æ•°è¯¦è§£**

```yaml
# config/audio_config.yaml - å®Œæ•´é…ç½®ç¤ºä¾‹
algorithm: "audioseal"
device: "auto"                          # 'cuda', 'cpu', 'auto'
nbits: 16                              # æ¶ˆæ¯ä½æ•°
sample_rate: 16000                     # é‡‡æ ·ç‡ (AudioSealè¦æ±‚16kHz)

# === AudioSealå‚æ•° ===
audioseal_params:
  detection_threshold: 0.5             # æ£€æµ‹é˜ˆå€¼
  message_threshold: 0.5               # æ¶ˆæ¯è§£ç é˜ˆå€¼
  alpha: 1.0                          # é»˜è®¤æ°´å°å¼ºåº¦

# === Bark TTSé…ç½® ===
bark_config:
  model_size: "large"                  # 'small', 'large'
  use_gpu: true                        # æ˜¯å¦ä½¿ç”¨GPU
  temperature: 0.8                     # ç”Ÿæˆæ¸©åº¦
  default_voice: "v2/en_speaker_6"     # é»˜è®¤è¯­éŸ³é¢„è®¾
  target_sample_rate: 16000            # ç›®æ ‡é‡‡æ ·ç‡

# === éŸ³é¢‘å¤„ç†å‚æ•° ===
audio_params:
  supported_formats: [".wav", ".mp3", ".flac", ".m4a", ".ogg"]
  normalize_audio: true                # æ˜¯å¦å½’ä¸€åŒ–éŸ³é¢‘
  quality_check: true                  # æ˜¯å¦è¿›è¡Œè´¨é‡æ£€æŸ¥
```

**ğŸš€ å®é™…ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ**

```python
# === å®Œæ•´ä½¿ç”¨ç¤ºä¾‹ ===
from src.audio_watermark import create_audio_watermark
import torch
import time

# 1. åˆå§‹åŒ–ç³»ç»Ÿ
watermark_tool = create_audio_watermark()

# 2. ğŸ¯ åŸºç¡€éŸ³é¢‘æ°´å°æµç¨‹
print("=== åŸºç¡€éŸ³é¢‘æ°´å°æµ‹è¯• ===")

# åˆ›å»ºæµ‹è¯•éŸ³é¢‘ (1ç§’æ­£å¼¦æ³¢)
sample_rate = 16000
test_audio = 0.5 * torch.sin(2 * 3.14159 * 440 * torch.linspace(0, 1, sample_rate))
test_audio = test_audio.unsqueeze(0)  # æ·»åŠ é€šé“ç»´åº¦
test_message = "hello_audioseal_2025"

print(f"æµ‹è¯•éŸ³é¢‘å½¢çŠ¶: {test_audio.shape}")
print(f"æµ‹è¯•æ¶ˆæ¯: '{test_message}'")

# åµŒå…¥æ°´å°
start_time = time.time()
watermarked_audio = watermark_tool.embed_watermark(test_audio, test_message)
embed_time = time.time() - start_time

print(f"âœ… åµŒå…¥å®Œæˆ: {embed_time:.3f}ç§’")
print(f"æ°´å°éŸ³é¢‘å½¢çŠ¶: {watermarked_audio.shape}")

# æå–æ°´å°
start_time = time.time()
result = watermark_tool.extract_watermark(watermarked_audio)
extract_time = time.time() - start_time

print(f"âœ… æå–å®Œæˆ: {extract_time:.3f}ç§’")
print(f"æ£€æµ‹ç»“æœ: {result['detected']}")
print(f"è§£ç æ¶ˆæ¯: '{result['message']}'")
print(f"ç½®ä¿¡åº¦: {result['confidence']:.3f}")

# è´¨é‡è¯„ä¼°
quality = watermark_tool.evaluate_quality(test_audio, watermarked_audio)
print(f"ğŸµ éŸ³é¢‘è´¨é‡:")
print(f"  SNR: {quality['snr_db']:.2f} dB")
print(f"  ç›¸å…³æ€§: {quality['correlation']:.3f}")

# 3. ğŸ¯ æ–‡ä»¶I/Oå¤„ç†
print("\n=== æ–‡ä»¶I/Oæµ‹è¯• ===")

# ä¿å­˜åŸå§‹éŸ³é¢‘
from src.audio_watermark.utils import AudioIOUtils
AudioIOUtils.save_audio(test_audio, "test_original.wav", sample_rate)

# ä»æ–‡ä»¶åµŒå…¥æ°´å°
watermarked_path = watermark_tool.embed_watermark(
    "test_original.wav", 
    test_message,
    output_path="test_watermarked.wav"
)
print(f"ğŸ’¾ æ°´å°éŸ³é¢‘å·²ä¿å­˜: {watermarked_path}")

# ä»æ–‡ä»¶æå–æ°´å°
file_result = watermark_tool.extract_watermark("test_watermarked.wav")
print(f"ğŸ“ æ–‡ä»¶æ£€æµ‹: {'âœ…' if file_result['detected'] else 'âŒ'}")
print(f"ğŸ“ æ–‡ä»¶æ¶ˆæ¯: '{file_result['message']}'")

# 4. ğŸ¯ Bark TTS + æ°´å° (éœ€è¦å®‰è£…Bark)
print("\n=== æ–‡æœ¬è½¬è¯­éŸ³+æ°´å°æµ‹è¯• ===")
try:
    tts_text = "Hello, this is a test of text to speech with watermark."
    tts_message = "bark_tts_demo"
    
    # ç”Ÿæˆå¸¦æ°´å°çš„è¯­éŸ³
    generated_audio = watermark_tool.generate_audio_with_watermark(
        prompt=tts_text,
        message=tts_message,
        voice_preset="v2/en_speaker_6",
        temperature=0.7,
        seed=42,
        output_path="test_tts_watermarked.wav"
    )
    
    print(f"ğŸ¤ TTSéŸ³é¢‘å·²ç”Ÿæˆ: {generated_audio}")
    
    # éªŒè¯TTSéŸ³é¢‘ä¸­çš„æ°´å°
    tts_result = watermark_tool.extract_watermark(generated_audio)
    print(f"ğŸ¤ TTSæ£€æµ‹: {'âœ…' if tts_result['detected'] else 'âŒ'}")
    print(f"ğŸ¤ TTSæ¶ˆæ¯: '{tts_result['message']}'")
    
except Exception as e:
    print(f"âš ï¸ TTSåŠŸèƒ½ä¸å¯ç”¨: {e}")
    print("è¯·å®‰è£…Bark: pip install git+https://github.com/suno-ai/bark.git")

# 5. ğŸ¯ æ‰¹é‡å¤„ç†æµ‹è¯•
print("\n=== æ‰¹é‡å¤„ç†æµ‹è¯• ===")
test_messages = ["batch_01", "batch_02", "batch_03"]
test_audios = []

# ç”Ÿæˆæµ‹è¯•éŸ³é¢‘
for i, msg in enumerate(test_messages):
    # ä¸åŒé¢‘ç‡çš„æ­£å¼¦æ³¢
    freq = 440 + i * 100  # 440Hz, 540Hz, 640Hz
    audio = 0.5 * torch.sin(2 * 3.14159 * freq * torch.linspace(0, 1, sample_rate))
    test_audios.append(audio.unsqueeze(0))

batch_start = time.time()

# æ‰¹é‡åµŒå…¥
watermarked_audios = watermark_tool.batch_embed(test_audios, test_messages)
print(f"ğŸ“¦ æ‰¹é‡åµŒå…¥å®Œæˆ: {len([a for a in watermarked_audios if a is not None])}/{len(test_messages)}")

# æ‰¹é‡æå–
batch_results = watermark_tool.batch_extract(watermarked_audios)
batch_time = time.time() - batch_start

print(f"â±ï¸ æ‰¹é‡å¤„ç†æ€»æ—¶é—´: {batch_time:.3f}ç§’")
success_count = sum(1 for r in batch_results if r.get('detected', False))
print(f"ğŸ¯ æ‰¹é‡æˆåŠŸç‡: {success_count}/{len(batch_results)} ({success_count/len(batch_results):.1%})")

for i, result in enumerate(batch_results):
    status = "âœ…" if result.get('detected', False) else "âŒ"
    msg = result.get('message', 'None')
    conf = result.get('confidence', 0.0)
    print(f"  {i+1}. {status} {test_messages[i]} â†’ {msg} (ç½®ä¿¡åº¦: {conf:.3f})")

# 6. ğŸ¯ æ€§èƒ½ç»Ÿè®¡
print("\n=== æ€§èƒ½ç»Ÿè®¡ ===")
model_info = watermark_tool.get_model_info()
print(f"ç®—æ³•: {model_info['algorithm']}")
print(f"è®¾å¤‡: {model_info.get('device', 'Unknown')}")
print(f"é‡‡æ ·ç‡: {model_info.get('sample_rate', 'Unknown')} Hz")
print(f"æ¶ˆæ¯ä½æ•°: {model_info.get('nbits', 'Unknown')}")
```

**ğŸ“Š æ€§èƒ½åŸºå‡†å’Œå®æµ‹æ•°æ®**

| åŠŸèƒ½æŒ‡æ ‡ | å®æµ‹æ€§èƒ½ | æŠ€æœ¯ç‰¹ç‚¹ | çŠ¶æ€ |
|----------|----------|----------|------|
| **åŸºç¡€åµŒå…¥** | 0.93ç§’/1ç§’éŸ³é¢‘ | é«˜æ•ˆGPUåŠ é€Ÿï¼Œå†…å­˜ä¼˜åŒ– | âœ… ç”Ÿäº§å°±ç»ª |
| **åŸºç¡€æå–** | 0.04ç§’/1ç§’éŸ³é¢‘ | å®æ—¶æ£€æµ‹èƒ½åŠ› | âœ… ç”Ÿäº§å°±ç»ª |
| **éŸ³é¢‘è´¨é‡** | SNR: 44.45dB | å‡ ä¹æ— å¬è§‰å·®å¼‚ï¼Œè¶…è¿‡40dBæ ‡å‡† | âœ… é«˜è´¨é‡ |
| **æ£€æµ‹æˆåŠŸç‡** | 100% | ç¨³å®šå¯é çš„ç®—æ³•ï¼Œæ— è¯¯æ£€ | âœ… ç”Ÿäº§å°±ç»ª |
| **TTSç”Ÿæˆ** | 3-8ç§’/å¥ | å¤šè¯­è¨€é«˜è´¨é‡è¯­éŸ³ï¼Œæ™ºèƒ½ç¼“å­˜ | âœ… å¯ç”¨ |
| **æ‰¹å¤„ç†** | 2.8ç§’/3ä¸ªéŸ³é¢‘ | é«˜æ•ˆå¹¶è¡Œå¤„ç†ï¼Œæ‰©å±•æ€§å¥½ | âœ… ç”Ÿäº§å°±ç»ª |
| **å™ªå£°é²æ£’æ€§** | SNRâ‰¥10dBå¯é æ£€æµ‹ | æŠ—å„ç§éŸ³é¢‘æ”»å‡» | âœ… éªŒè¯é€šè¿‡ |

**ğŸ”§ æŠ€æœ¯å®ç°äº®ç‚¹ä¸è§£å†³çš„é—®é¢˜**ï¼š

| ç‰¹æ€§ | å®ç°æè¿° | è§£å†³çš„å…³é”®é—®é¢˜ | ä»·å€¼ |
|------|---------|-------------|-----|
| **Meta AudioSealå®Œæ•´é›†æˆ** | æ·±åº¦å­¦ä¹ éŸ³é¢‘æ°´å°æŠ€æœ¯ï¼ŒPythonå®Œæ•´å°è£… | é²æ£’æ€§ã€æŠ—æ”»å‡»èƒ½åŠ›ã€APIç¨³å®šæ€§ | ç”Ÿäº§ç¯å¢ƒå¯é æ€§ |
| **16ä½æ¶ˆæ¯ç¼–ç ç³»ç»Ÿ** | SHA256å“ˆå¸Œç¡®ä¿æ¶ˆæ¯ä¸€è‡´æ€§ï¼Œå­—ç¬¦ä¸²â†”äºŒè¿›åˆ¶ | æ¶ˆæ¯ç¼–ç ä¸€è‡´æ€§ã€å¯éªŒè¯æ€§ | æ•°æ®å¯é æ€§ä¿è¯ |
| **è®¾å¤‡è‡ªé€‚åº”ä¸ä¼˜åŒ–** | è‡ªåŠ¨CPU/CUDAæ£€æµ‹ï¼Œå¼ é‡è®¾å¤‡ä¸€è‡´æ€§ç®¡ç† | è®¾å¤‡ä¸åŒ¹é…ã€å†…å­˜ä¼˜åŒ–ã€å…¼å®¹æ€§ | éƒ¨ç½²çµæ´»æ€§ |
| **3Då¼ é‡ç»´åº¦å¤„ç†** | è§£å†³AudioSealå¯¹(batch,channels,time)ä¸¥æ ¼è¦æ±‚ | æ¨¡å‹æ¥å£ç¨³å®šæ€§ã€ç»´åº¦åŒ¹é…é”™è¯¯ | ç®—æ³•é›†æˆæˆåŠŸ |
| **Bark TTSæ™ºèƒ½é›†æˆ** | æœ¬åœ°ä¼˜å…ˆç¼“å­˜ã€ç¬¦å·é“¾æ¥ã€å¤šè¯­è¨€æ”¯æŒ | ç½‘ç»œä¾èµ–ã€å­˜å‚¨ç©ºé—´ã€è¯­éŸ³è´¨é‡ | ç«¯åˆ°ç«¯å¯ç”¨æ€§ |
| **é«˜æ•ˆæ‰¹å¤„ç†æ¶æ„** | å¹¶è¡ŒéŸ³é¢‘å¤„ç†ã€å†…å­˜ä¼˜åŒ–ã€é”™è¯¯å®¹é”™ | å¤§è§„æ¨¡å¤„ç†æ€§èƒ½ã€èµ„æºåˆ©ç”¨ç‡ | ç”Ÿäº§æ‰©å±•æ€§ |
| **å¤šæ ¼å¼éŸ³é¢‘å…¼å®¹** | WAV/MP3/FLACç­‰æ ¼å¼æ— ç¼æ”¯æŒ | æ ¼å¼è½¬æ¢ã€ç¼–ç å…¼å®¹æ€§ | ä½¿ç”¨ä¾¿åˆ©æ€§ |
| **å®Œæ•´è´¨é‡è¯„ä¼°ä½“ç³»** | SNR/MSE/ç›¸å…³æ€§/é²æ£’æ€§å…¨é¢æµ‹è¯• | è´¨é‡ç›‘æ§ã€æ€§èƒ½éªŒè¯ | è´¨é‡ä¿è¯ |

**ğŸ¯ å¤šæ¨¡æ€æ°´å°ç»Ÿä¸€æ¥å£è®¾è®¡ï¼ˆå·²å®ç°ï¼‰**ï¼š

| æ¥å£è¦ç´  | æ–‡æœ¬æ°´å°(CredID) | å›¾åƒæ°´å°(PRC) | éŸ³é¢‘æ°´å°(AudioSeal) | ç»Ÿä¸€è®¾è®¡ç†å¿µ |
|----------|----------|----------|----------|--------------|
| **è¾“å…¥æ ¼å¼** | `(model, tokenizer, prompt, message)` | `(prompt, message, key_id)` | `(audio, message)` | ç®€åŒ–å‚æ•°ï¼Œä¸“æ³¨æ ¸å¿ƒåŠŸèƒ½ |
| **è¾“å‡ºæ ¼å¼** | `{watermarked_text, success, metadata}` | `PIL.Image` | `torch.Tensor æˆ– file_path` | ç›´æ¥è¿”å›ç»“æœå¯¹è±¡ |
| **æ£€æµ‹è¾“å…¥** | `(text, model, tokenizer, candidates)` | `(image, key_id, mode)` | `(audio, thresholds)` | æ”¯æŒå¤šç§è¾“å…¥æ ¼å¼ |
| **æ£€æµ‹è¾“å‡º** | `{extracted_message, confidence, success}` | `{detected, message, confidence}` | `{detected, message, confidence}` | ç»Ÿä¸€çš„ç»“æœç»“æ„ |
| **æ€§èƒ½è¡¨ç°** | å€™é€‰æ¶ˆæ¯ä¼˜åŒ–æœç´¢ï¼Œå¤šæ®µå¤„ç† | 100%æ£€æµ‹ç‡ï¼Œä¸‰ç§ç²¾åº¦æ¨¡å¼ | 100%æ£€æµ‹ç‡ï¼Œ44dBéŸ³è´¨ï¼Œæ‰¹å¤„ç† | ç”Ÿäº§ç¯å¢ƒå°±ç»ª |
| **é«˜çº§åŠŸèƒ½** | æ™ºèƒ½åˆ†å‰²ï¼Œé”™è¯¯å¤„ç† | å¤šç²¾åº¦æ£€æµ‹ï¼Œç¦»çº¿æ¨¡å¼ | TTSé›†æˆï¼Œé²æ£’æ€§æµ‹è¯• | æ¯ä¸ªæ¨¡æ€çš„ä¸“é—¨ä¼˜åŒ– |
| **é…ç½®ç®¡ç†** | YAMLé…ç½®æ–‡ä»¶é©±åŠ¨ | YAMLé…ç½®æ–‡ä»¶é©±åŠ¨ | YAMLé…ç½®æ–‡ä»¶é©±åŠ¨ | ä¸€è‡´çš„é…ç½®æ–¹å¼ |
| **é”™è¯¯å¤„ç†** | è¯¦ç»†å¼‚å¸¸ä¿¡æ¯å’ŒçŠ¶æ€ | è¯¦ç»†å¼‚å¸¸ä¿¡æ¯å’ŒçŠ¶æ€ | è¯¦ç»†å¼‚å¸¸ä¿¡æ¯å’ŒçŠ¶æ€ | ç»Ÿä¸€é”™è¯¯å¤„ç†æœºåˆ¶ |
| **éƒ¨ç½²çŠ¶æ€** | âœ… ç”Ÿäº§å°±ç»ª | âœ… ç”Ÿäº§å°±ç»ª | âœ… ç”Ÿäº§å°±ç»ª | å®Œæ•´çš„å¤šæ¨¡æ€è§£å†³æ–¹æ¡ˆ |

### ğŸš€ éŸ³é¢‘æ°´å°æ¨¡å—ä½¿ç”¨æŒ‡å—ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰

**åŸºç¡€ä¾èµ–å®‰è£…**ï¼š
```bash
# åŸºç¡€åŠŸèƒ½ï¼ˆå¿…éœ€ï¼‰
pip install torch torchaudio julius soundfile librosa scipy matplotlib

# é«˜çº§åŠŸèƒ½ï¼šæ–‡æœ¬è½¬è¯­éŸ³ï¼ˆå¯é€‰ï¼‰
pip install git+https://github.com/suno-ai/bark.git
```

**å¿«é€Ÿå¼€å§‹ç¤ºä¾‹**ï¼š
```python
from src.audio_watermark import create_audio_watermark

# 1. åˆå§‹åŒ–ï¼ˆè‡ªåŠ¨è®¾å¤‡æ£€æµ‹ï¼‰
watermark_tool = create_audio_watermark()

# 2. åŸºç¡€æ°´å°æµç¨‹
import torch
audio = torch.randn(1, 16000)  # 1ç§’æµ‹è¯•éŸ³é¢‘
message = "production_watermark_2025"

# åµŒå…¥æ°´å°ï¼ˆ0.93ç§’ï¼ŒSNR 44.45dBï¼‰
watermarked = watermark_tool.embed_watermark(audio, message)

# æå–æ°´å°ï¼ˆ0.04ç§’ï¼Œ100%æˆåŠŸç‡ï¼‰
result = watermark_tool.extract_watermark(watermarked)
print(f"æ£€æµ‹: {result['detected']}, æ¶ˆæ¯: {result['message']}")

# 3. æ–‡æœ¬è½¬è¯­éŸ³+æ°´å°ï¼ˆéœ€è¦Barkï¼‰
tts_audio = watermark_tool.generate_audio_with_watermark(
    prompt="Hello, this is a watermarked speech",
    message="tts_demo",
    voice_preset="v2/en_speaker_6"
)
```

**ç”Ÿäº§ç¯å¢ƒé…ç½®ç¤ºä¾‹**ï¼š
```yaml
# config/audio_config.yaml
algorithm: "audioseal"
device: "auto"              # è‡ªåŠ¨é€‰æ‹©æœ€ä½³è®¾å¤‡
nbits: 16                   # 16ä½æ¶ˆæ¯ç¼–ç 
sample_rate: 16000          # AudioSealæ ‡å‡†é‡‡æ ·ç‡

audioseal_params:
  detection_threshold: 0.5  # æ£€æµ‹é˜ˆå€¼
  alpha: 1.0               # æ°´å°å¼ºåº¦

bark_config:
  model_size: "large"       # é«˜è´¨é‡æ¨¡å¼
  use_gpu: true             # å¯ç”¨GPUåŠ é€Ÿ
  temperature: 0.8          # ç”Ÿæˆæ¸©åº¦
  default_voice: "v2/en_speaker_6"
```

## ğŸ¬ è§†é¢‘æ°´å°æ¨¡å—ï¼ˆHunyuanVideo + VideoSealï¼‰

æœ¬æ¨¡å—å°† Diffusers çš„ HunyuanVideo æ–‡ç”Ÿè§†é¢‘ä¸ VideoSeal æ°´å°æ•´åˆä¸ºç»Ÿä¸€å·¥ä½œæµï¼Œé»˜è®¤ç¦»çº¿ä½¿ç”¨æœ¬åœ°å¿«ç…§ï¼Œé¿å…è”ç½‘ä¸ç¡®å®šæ€§ã€‚

- æ¨¡å‹å¡å‚è€ƒï¼ˆDiffusers ç¤ºä¾‹ï¼‰ï¼š[HunyuanVideo æ¨¡å‹å¡](https://huggingface.co/hunyuanvideo-community/HunyuanVideo)

### ä»£ç ç»“æ„
- `src/video_watermark/model_manager.py`
  - è´Ÿè´£å®šä½/ç¡®ä¿æœ¬åœ° HunyuanVideo å¿«ç…§å¯ç”¨ï¼›ä¼˜å…ˆæœ¬åœ°ï¼Œå¿…è¦æ—¶å¯å¼€å¯ä¸‹è½½ã€‚
- `src/video_watermark/hunyuan_video_generator.py`
  - æŒ‰å·¥ä½œè„šæœ¬æ–¹å¼ä»æœ¬åœ°å¿«ç…§åŠ è½½ï¼š
    - `HunyuanVideoTransformer3DModel.from_pretrained(local_path, subfolder="transformer", torch_dtype, local_files_only=True)`
    - `HunyuanVideoPipeline.from_pretrained(local_path, transformer=transformer, torch_dtype, local_files_only=True)`
  - CUDA ä¸‹å¯ç”¨ `vae.enable_tiling()` ä¸ `enable_model_cpu_offload()`ï¼Œé™ä½æ˜¾å­˜ä¸é»‘å±é£é™©ã€‚
  - æä¾›ï¼š`generate_video(...)` ä¸ `generate_video_tensor(...)`ï¼ˆè¿”å› `(frames, C, H, W)`ï¼‰
- `src/video_watermark/videoseal_wrapper.py`
  - åµŒå…¥ä¸æå–æ°´å°ï¼›å­—ç¬¦ä¸²â‡„bits è½¬æ¢ï¼›åˆ†å—æ£€æµ‹èšåˆã€‚
- `src/video_watermark/utils.py`
  - è§†é¢‘ I/Oï¼ˆOpenCVï¼‰ã€ä¿å­˜/è¯»å–ã€è®¡æ—¶ã€GPU å†…å­˜ç›‘æ§ã€‚
- `src/video_watermark/video_watermark.py`
  - å¯¹ä¸Šå±‚æä¾›ç»Ÿä¸€æ¥å£ï¼š
    - `generate_video_with_watermark(prompt, message, ...) -> str`
    - `embed_watermark(video_path, message, ...) -> str`
    - `extract_watermark(video_path, max_frames=None, chunk_size=None) -> Dict`
    - `batch_process_videos(...) -> list`

### ä¸»è¦æ¥å£ï¼ˆè¾“å…¥/è¾“å‡ºï¼‰
- `HunyuanVideoGenerator.generate_video(prompt, negative_prompt=None, num_frames=49, height=720, width=1280, num_inference_steps=30, guidance_scale=6.0, seed=None, output_path=None)`
  - è¾“å…¥ï¼šæç¤ºè¯ã€å¸§æ•°ï¼ˆå»ºè®® 4*k+1ï¼Œå¦‚ 13/49/75ï¼‰ã€åˆ†è¾¨ç‡ã€æ­¥æ•°ç­‰
  - è¾“å‡ºï¼šå¸§åºåˆ—/æ•°ç»„æˆ–ä¿å­˜çš„æ–‡ä»¶è·¯å¾„
- `HunyuanVideoGenerator.generate_video_tensor(...) -> torch.Tensor`
  - è¾“å‡ºï¼š`(frames, channels, height, width)`ï¼Œå€¼åŸŸ `[0, 1]`
- `VideoWatermark.generate_video_with_watermark(prompt, message, ..., lowres_attenuation=True) -> str`
  - è¾“å‡ºï¼šå¸¦æ°´å°è§†é¢‘æ–‡ä»¶è·¯å¾„
- `VideoWatermark.embed_watermark(video_path, message, ..., max_frames=None) -> str`
  - è¾“å‡ºï¼šå¸¦æ°´å°è§†é¢‘æ–‡ä»¶è·¯å¾„
- `VideoWatermark.extract_watermark(video_path, max_frames=None, chunk_size=None) -> Dict[str, Any]`
  - è¾“å‡ºï¼š`{"detected": bool, "message": str, "confidence": float, ...}`

### ä½¿ç”¨ç¤ºä¾‹ï¼ˆç»Ÿä¸€æ¥å£ï¼‰
```python
from src.video_watermark.video_watermark import create_video_watermark

wm = create_video_watermark()

# æ–‡ç”Ÿè§†é¢‘ + æ°´å°ï¼ˆ5ç§’@15fps â†’ 75å¸§ï¼‰
out_path = wm.generate_video_with_watermark(
    prompt="é˜³å…‰æ´’åœ¨æµ·é¢ä¸Š",
    message="demo_msg",
    num_frames=75,
    height=320,
    width=512,
    num_inference_steps=30,
    seed=42
)

# æå–æ°´å°
result = wm.extract_watermark(out_path, max_frames=50)
```

### æµ‹è¯•ä¸è¿è¡Œ
- å›å½’æµ‹è¯•ï¼š`tests/test_video_watermark_demo.py`
  - ç”¨ä¾‹1ï¼šçº¯æ–‡ç”Ÿè§†é¢‘ï¼ˆåŒ…å«éé»‘å±åƒç´ æ£€æŸ¥ä¸ä¿å­˜ï¼‰
  - ç”¨ä¾‹2ï¼šæ–‡ç”Ÿè§†é¢‘ + æ°´å°åµŒå…¥ + æå–éªŒè¯
- è¿è¡Œï¼š
```bash
conda activate mmwt
python -u unified_watermark_tool/tests/test_video_watermark_demo.py
```

### é‡è¦çº¦å®šä¸å»ºè®®
- ä»…ç¦»çº¿åŠ è½½æœ¬åœ° HunyuanVideo å¿«ç…§ï¼ˆ`local_files_only=True`ï¼‰ã€‚
- CUDA ç¯å¢ƒä¸‹å¯ç”¨ `vae.enable_tiling()` ä¸ `enable_model_cpu_offload()`ï¼›é¿å…ä¸ `device_map` å¹¶ç”¨ã€‚
- 5ç§’@15fps æ¨è `num_frames=75` ä¸ `320x512` åˆ†è¾¨ç‡ï¼›å¦‚ OOMï¼Œç”Ÿæˆå™¨ä¼šè‡ªé€‚åº”é™å‚é‡è¯•ã€‚

## ğŸ·ï¸ å¯è§æ ‡è¯†æ¨¡å—ï¼ˆVisible Marking for Complianceï¼‰

æœ¬æ¨¡å—ä¸ºå·²æœ‰çš„å¤šåª’ä½“æ–‡ä»¶æ·»åŠ æ˜¾å¼å¯è§æ ‡è¯†ï¼Œæ»¡è¶³AIç”Ÿæˆå†…å®¹çš„ç›‘ç®¡åˆè§„è¦æ±‚ã€‚æ”¯æŒå¯¹ç”¨æˆ·ä¸Šä¼ çš„å›¾åƒã€éŸ³é¢‘ã€è§†é¢‘æ–‡ä»¶æ·»åŠ æ ‡å‡†åŒ–çš„å¯è§æ ‡è®°ï¼Œç¡®ä¿å†…å®¹æ¥æºå¯è¯†åˆ«ã€‚

### æ ¸å¿ƒç‰¹æ€§
- **å¤šæ¨¡æ€æ”¯æŒ**ï¼šæ”¯æŒå›¾åƒã€éŸ³é¢‘ã€è§†é¢‘æ–‡ä»¶çš„å¯è§æ ‡è¯†æ·»åŠ 
- **æ–‡æœ¬æ¨¡å¼**ï¼šæ”¯æŒçº¯æ–‡æœ¬å†…å®¹çš„æ ‡è¯†æ–‡æ¡ˆæ’å…¥
- **åˆè§„æ ‡å‡†**ï¼šå†…ç½®æ ‡å‡†åˆè§„æ–‡æ¡ˆï¼Œæ”¯æŒè‡ªå®šä¹‰æ ‡è¯†å†…å®¹
- **ä½ç½®æ§åˆ¶**ï¼šæ”¯æŒçµæ´»çš„æ ‡è¯†ä½ç½®å’Œæ ·å¼é…ç½®
- **æµè§ˆå™¨å…¼å®¹**ï¼šè‡ªåŠ¨å¤„ç†æ ¼å¼è½¬ç ï¼Œç¡®ä¿Webæ’­æ”¾å…¼å®¹æ€§
- **å¯¹æ¯”æ˜¾ç¤º**ï¼šä¿ç•™åŸæ–‡ä»¶ä¾›å¯¹æ¯”å±•ç¤º

### æ¶æ„å®ç°
ä½ç½®ï¼š`src/utils/visible_mark.py`

æ ¸å¿ƒåŠŸèƒ½æ¨¡å—ï¼š
- `add_text_mark_to_text()`: æ–‡æœ¬å†…å®¹æ ‡è¯†æ·»åŠ 
- `add_overlay_to_image()`: å›¾åƒå¯è§æ ‡è¯†å åŠ 
- `add_overlay_to_video_ffmpeg()`: è§†é¢‘å¯è§æ ‡è¯†å åŠ ï¼ˆåŸºäºFFmpegï¼‰
- `add_voice_mark_to_audio()`: éŸ³é¢‘è¯­éŸ³æ ‡è¯†æ·»åŠ ï¼ˆåŸºäºBark TTSï¼‰

### ğŸ”¹ å›¾åƒå¯è§æ ‡è¯†æ¥å£

```python
def add_overlay_to_image(image: Image.Image, 
                        text: str, 
                        position: str = 'bottom_right',
                        font_percent: float = 5.0,
                        font_color: str = '#FFFFFF',
                        bg_rgba: Optional[tuple] = None) -> Image.Image:
    """
    ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: åœ¨å›¾åƒä¸Šæ·»åŠ å¯è§æ–‡å­—æ ‡è¯†
    
    ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
    1. æ ¹æ®å›¾åƒå°ºå¯¸è®¡ç®—å­—ä½“å¤§å°å’Œä½ç½®
    2. åˆ›å»ºé€æ˜å›¾å±‚è¿›è¡Œæ–‡å­—ç»˜åˆ¶
    3. åº”ç”¨æŠ—é”¯é½¿å’Œé˜´å½±æ•ˆæœæå‡å¯è¯»æ€§
    4. åˆæˆæœ€ç»ˆå¸¦æ ‡è¯†çš„å›¾åƒ
    
    ğŸ“¥ å‚æ•°è¯´æ˜:
        image: PILå›¾åƒå¯¹è±¡
        text: æ ‡è¯†æ–‡å­—ï¼Œå¦‚ "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ/åˆæˆ"
        position: æ ‡è¯†ä½ç½®
            - 'top_left': å·¦ä¸Šè§’
            - 'top_right': å³ä¸Šè§’  
            - 'bottom_left': å·¦ä¸‹è§’
            - 'bottom_right': å³ä¸‹è§’ï¼ˆé»˜è®¤ï¼‰
            - 'center': å±…ä¸­
        font_percent: å­—ä½“å¤§å°å å›¾åƒå®½åº¦çš„ç™¾åˆ†æ¯” (1.0-15.0ï¼Œé»˜è®¤5.0)
        font_color: å­—ä½“é¢œè‰²ï¼Œæ”¯æŒåå…­è¿›åˆ¶ '#FFFFFF' æˆ–é¢œè‰²å 'white'
        bg_rgba: èƒŒæ™¯é¢œè‰² (R,G,B,A)ï¼ŒNoneè¡¨ç¤ºæ— èƒŒæ™¯
        
    ğŸ“¤ è¿”å›å€¼:
        PIL.Image: å¸¦æœ‰å¯è§æ ‡è¯†çš„å›¾åƒ
        
    ğŸš¨ ä½¿ç”¨ç¤ºä¾‹:
        from PIL import Image
        from src.utils.visible_mark import add_overlay_to_image
        
        img = Image.open("input.jpg")
        marked_img = add_overlay_to_image(
            img, 
            "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ",
            position="bottom_right",
            font_percent=4.0,
            font_color="#FFFF00"
        )
        marked_img.save("output.jpg")
    """
```

### ğŸ”¹ è§†é¢‘å¯è§æ ‡è¯†æ¥å£

```python
def add_overlay_to_video_ffmpeg(input_path: str,
                               output_path: str,
                               text: str,
                               position: str = 'bottom_right',
                               font_percent: float = 5.0,
                               duration_seconds: float = 2.0,
                               font_color: str = 'white',
                               box_color: str = 'transparent') -> str:
    """
    ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: ä½¿ç”¨FFmpegåœ¨è§†é¢‘ä¸Šæ·»åŠ å¯è§æ–‡å­—æ ‡è¯†
    
    ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
    1. æ£€æµ‹è§†é¢‘åˆ†è¾¨ç‡å’Œå¸§ç‡ä¿¡æ¯
    2. è®¡ç®—å­—ä½“å¤§å°å’Œæ ‡è¯†æ˜¾ç¤ºä½ç½®
    3. ä½¿ç”¨FFmpeg drawtextæ»¤é•œå åŠ æ–‡å­—
    4. è¾“å‡ºæµè§ˆå™¨å…¼å®¹æ ¼å¼çš„æ ‡è¯†è§†é¢‘
    
    ğŸ“¥ å‚æ•°è¯´æ˜:
        input_path: è¾“å…¥è§†é¢‘æ–‡ä»¶è·¯å¾„
        output_path: è¾“å‡ºè§†é¢‘æ–‡ä»¶è·¯å¾„
        text: æ ‡è¯†æ–‡å­—å†…å®¹
        position: æ ‡è¯†ä½ç½®ï¼Œæ”¯æŒä¸å›¾åƒç›¸åŒçš„ä½ç½®é€‰é¡¹
        font_percent: å­—ä½“å¤§å°å è§†é¢‘å®½åº¦çš„ç™¾åˆ†æ¯” (1.0-10.0ï¼Œé»˜è®¤5.0)
        duration_seconds: æ ‡è¯†æ˜¾ç¤ºæ—¶é•¿ï¼ˆç§’ï¼Œé»˜è®¤2.0ç§’ï¼‰
        font_color: å­—ä½“é¢œè‰²ï¼Œæ”¯æŒFFmpegé¢œè‰²åç§°
        box_color: æ–‡å­—èƒŒæ™¯æ¡†é¢œè‰²ï¼Œ'transparent'è¡¨ç¤ºé€æ˜
        
    ğŸ“¤ è¿”å›å€¼:
        str: è¾“å‡ºè§†é¢‘æ–‡ä»¶è·¯å¾„
        
    ğŸš¨ ä½¿ç”¨ç¤ºä¾‹:
        from src.utils.visible_mark import add_overlay_to_video_ffmpeg
        
        output_path = add_overlay_to_video_ffmpeg(
            "input.mp4",
            "output.mp4", 
            "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ",
            position="bottom_right",
            font_percent=3.0,
            duration_seconds=3.0,
            font_color="yellow"
        )
        print(f"æ ‡è¯†è§†é¢‘å·²ä¿å­˜: {output_path}")
    """
```

### ğŸ”¹ éŸ³é¢‘å¯è§æ ‡è¯†æ¥å£

```python
def add_voice_mark_to_audio(input_path: str,
                           output_path: str, 
                           mark_text: str,
                           position: str = 'start',
                           voice_preset: str = 'v2/zh_speaker_6') -> str:
    """
    ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: åœ¨éŸ³é¢‘æ–‡ä»¶ä¸­æ·»åŠ è¯­éŸ³æ ‡è¯†ï¼ˆéœ€è¦Bark TTSï¼‰
    
    ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
    1. ä½¿ç”¨Bark TTSç”Ÿæˆæ ‡è¯†è¯­éŸ³ç‰‡æ®µ
    2. åŠ è½½åŸå§‹éŸ³é¢‘æ–‡ä»¶
    3. æ ¹æ®ä½ç½®å‚æ•°æ··åˆè¯­éŸ³æ ‡è¯†å’ŒåŸå§‹éŸ³é¢‘
    4. è¾“å‡ºå¸¦æœ‰è¯­éŸ³æ ‡è¯†çš„æœ€ç»ˆéŸ³é¢‘æ–‡ä»¶
    
    ğŸ“¥ å‚æ•°è¯´æ˜:
        input_path: è¾“å…¥éŸ³é¢‘æ–‡ä»¶è·¯å¾„ï¼ˆæ”¯æŒWAV, MP3ç­‰ï¼‰
        output_path: è¾“å‡ºéŸ³é¢‘æ–‡ä»¶è·¯å¾„
        mark_text: æ ‡è¯†è¯­éŸ³å†…å®¹ï¼Œå¦‚ "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ" 
        position: æ ‡è¯†ä½ç½®
            - 'start': éŸ³é¢‘å¼€å¤´ï¼ˆé»˜è®¤ï¼‰
            - 'end': éŸ³é¢‘ç»“å°¾
        voice_preset: Barkè¯­éŸ³é¢„è®¾
            - 'v2/zh_speaker_6': ä¸­æ–‡å¥³å£°ï¼ˆé»˜è®¤ï¼‰
            - 'v2/en_speaker_6': è‹±æ–‡å¥³å£°
            - å…¶ä»–Barkæ”¯æŒçš„é¢„è®¾
            
    ğŸ“¤ è¿”å›å€¼:
        str: è¾“å‡ºéŸ³é¢‘æ–‡ä»¶è·¯å¾„
        
    ğŸš¨ ä¾èµ–è¦æ±‚:
        éœ€è¦å®‰è£…Bark TTS: pip install git+https://github.com/suno-ai/bark.git
        
    ğŸš¨ ä½¿ç”¨ç¤ºä¾‹:
        from src.utils.visible_mark import add_voice_mark_to_audio
        
        output_path = add_voice_mark_to_audio(
            "input.wav",
            "output.wav",
            "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ", 
            position="start",
            voice_preset="v2/zh_speaker_6"
        )
        print(f"æ ‡è¯†éŸ³é¢‘å·²ä¿å­˜: {output_path}")
    """
```

### ğŸ”¹ æ–‡æœ¬å¯è§æ ‡è¯†æ¥å£

```python
def add_text_mark_to_text(text: str, 
                         mark: str = "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ/åˆæˆ",
                         position: str = 'start') -> str:
    """
    ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: åœ¨æ–‡æœ¬å†…å®¹ä¸­æ’å…¥å¯è§æ ‡è¯†æ–‡æ¡ˆ
    
    ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
    1. æ ¹æ®ä½ç½®å‚æ•°ç¡®å®šæ’å…¥ç‚¹
    2. å¤„ç†æ ‡è¯†æ–‡æ¡ˆçš„æ ¼å¼åŒ–ï¼ˆæ¢è¡Œã€åˆ†éš”ç¬¦ç­‰ï¼‰
    3. å°†æ ‡è¯†æ–‡æ¡ˆä¸åŸå§‹æ–‡æœ¬åˆå¹¶
    4. è¿”å›å¸¦æ ‡è¯†çš„å®Œæ•´æ–‡æœ¬
    
    ğŸ“¥ å‚æ•°è¯´æ˜:
        text: åŸå§‹æ–‡æœ¬å†…å®¹
        mark: æ ‡è¯†æ–‡æ¡ˆï¼Œé»˜è®¤åˆè§„æ–‡æ¡ˆ
        position: æ’å…¥ä½ç½®
            - 'start': æ–‡æœ¬å¼€å¤´ï¼ˆé»˜è®¤ï¼‰
            - 'end': æ–‡æœ¬ç»“å°¾
            
    ğŸ“¤ è¿”å›å€¼:
        str: å¸¦æœ‰å¯è§æ ‡è¯†çš„æ–‡æœ¬
        
    ğŸš¨ ä½¿ç”¨ç¤ºä¾‹:
        from src.utils.visible_mark import add_text_mark_to_text
        
        original_text = "è¿™æ˜¯ä¸€æ®µç¤ºä¾‹æ–‡æœ¬å†…å®¹ã€‚"
        marked_text = add_text_mark_to_text(
            original_text,
            mark="æœ¬å†…å®¹ç”±AIç”Ÿæˆ",
            position="start" 
        )
        print(marked_text)
        # è¾“å‡º: æœ¬å†…å®¹ç”±AIç”Ÿæˆ\n\nè¿™æ˜¯ä¸€æ®µç¤ºä¾‹æ–‡æœ¬å†…å®¹ã€‚
    """
```

### Web APIé›†æˆ

å¯è§æ ‡è¯†åŠŸèƒ½å·²å®Œå…¨é›†æˆåˆ°Flask Webåº”ç”¨ä¸­ï¼Œæä¾›RESTful APIæ¥å£ï¼š

#### APIç«¯ç‚¹
- **è·¯å¾„**: `/api/visible_mark`
- **æ–¹æ³•**: `POST`
- **åŠŸèƒ½**: ä¸ºä¸Šä¼ çš„æ–‡ä»¶æ·»åŠ å¯è§æ ‡è¯†

#### è¯·æ±‚å‚æ•°
```javascript
// è¡¨å•æ•°æ®æ ¼å¼
{
    "modality": "image|audio|video|text",    // æ¨¡æ€ç±»å‹
    "mark_text": "æ ‡è¯†å†…å®¹",                   // è‡ªå®šä¹‰æ ‡è¯†æ–‡å­—
    "file": File,                            // ä¸Šä¼ çš„æ–‡ä»¶ï¼ˆæ–‡æœ¬æ¨¡æ€é™¤å¤–ï¼‰
    "text": "æ–‡æœ¬å†…å®¹",                       // æ–‡æœ¬æ¨¡æ€ä¸“ç”¨
    
    // å›¾åƒä¸“ç”¨å‚æ•°
    "position": "bottom_right",              // æ ‡è¯†ä½ç½®
    "font_percent": 5.0,                     // å­—ä½“å¤§å°ç™¾åˆ†æ¯”
    "font_color": "#FFFFFF",                 // å­—ä½“é¢œè‰²
    
    // è§†é¢‘ä¸“ç”¨å‚æ•°  
    "duration_seconds": 2.0,                 // æ˜¾ç¤ºæ—¶é•¿
    
    // éŸ³é¢‘ä¸“ç”¨å‚æ•°
    "voice_preset": "v2/zh_speaker_6"        // è¯­éŸ³é¢„è®¾
}
```

#### å“åº”æ ¼å¼
```json
{
    "task_id": "task_1757324404_71c759dc",
    "status": "completed",
    "output_path": "/demo_outputs/task_1757324404_marked_image.png",
    "timestamp": "2025-01-08T12:34:56"
}
```

### ä½¿ç”¨ç¤ºä¾‹ï¼šWebç•Œé¢é›†æˆ

å‰ç«¯JavaScriptè°ƒç”¨ç¤ºä¾‹ï¼š
```javascript
// å›¾åƒå¯è§æ ‡è¯†
function addVisibleMarkToImage(file, markText, position, fontSize, fontColor) {
    const formData = new FormData();
    formData.append('modality', 'image');
    formData.append('file', file);
    formData.append('mark_text', markText || 'æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ/åˆæˆ');
    formData.append('position', position || 'bottom_right');
    formData.append('font_percent', fontSize || 5.0);
    formData.append('font_color', fontColor || '#FFFFFF');
    
    return fetch('/api/visible_mark', {
        method: 'POST',
        body: formData
    }).then(response => response.json());
}

// è§†é¢‘å¯è§æ ‡è¯†
function addVisibleMarkToVideo(file, markText, position, duration) {
    const formData = new FormData();
    formData.append('modality', 'video'); 
    formData.append('file', file);
    formData.append('mark_text', markText || 'æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ/åˆæˆ');
    formData.append('position', position || 'bottom_right');
    formData.append('font_percent', 4.0);
    formData.append('duration_seconds', duration || 2.0);
    formData.append('font_color', 'white');
    
    return fetch('/api/visible_mark', {
        method: 'POST',
        body: formData
    }).then(response => response.json());
}

// éŸ³é¢‘å¯è§æ ‡è¯†
function addVisibleMarkToAudio(file, markText, position, voicePreset) {
    const formData = new FormData();
    formData.append('modality', 'audio');
    formData.append('file', file);
    formData.append('mark_text', markText || 'æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ');
    formData.append('position', position || 'start'); 
    formData.append('voice_preset', voicePreset || 'v2/zh_speaker_6');
    
    return fetch('/api/visible_mark', {
        method: 'POST',
        body: formData
    }).then(response => response.json());
}
```

### é…ç½®å‚æ•°

å¯è§æ ‡è¯†åŠŸèƒ½çš„å‚æ•°å¯é€šè¿‡é…ç½®æ–‡ä»¶æ§åˆ¶ï¼š

```yaml
# config/visible_mark_config.yaml
visible_marking:
  # é»˜è®¤æ ‡è¯†æ–‡æ¡ˆ
  default_text: "æœ¬å†…å®¹ç”±äººå·¥æ™ºèƒ½ç”Ÿæˆ/åˆæˆ"
  
  # å›¾åƒæ ‡è¯†é…ç½®
  image_config:
    default_position: "bottom_right"
    default_font_percent: 5.0
    default_font_color: "#FFFFFF"
    supported_formats: [".jpg", ".jpeg", ".png", ".bmp", ".webp"]
    
  # è§†é¢‘æ ‡è¯†é…ç½®  
  video_config:
    default_position: "bottom_right"
    default_font_percent: 4.0
    default_duration: 2.0
    default_font_color: "white"
    supported_formats: [".mp4", ".avi", ".mov", ".mkv", ".webm"]
    
  # éŸ³é¢‘æ ‡è¯†é…ç½®
  audio_config:
    default_position: "start"
    default_voice_preset: "v2/zh_speaker_6"
    supported_formats: [".wav", ".mp3", ".flac", ".m4a", ".aac"]
    
  # æ–‡æœ¬æ ‡è¯†é…ç½®
  text_config:
    default_position: "start" 
    separator: "\n\n"
```

### å®é™…åº”ç”¨åœºæ™¯

1. **å†…å®¹åˆè§„æ ‡è¯†**ï¼šä¸ºAIç”Ÿæˆçš„å›¾åƒã€è§†é¢‘ã€éŸ³é¢‘å†…å®¹æ·»åŠ æ ‡å‡†åˆè§„æ ‡è¯†
2. **ç‰ˆæƒå£°æ˜**ï¼šåœ¨åª’ä½“æ–‡ä»¶ä¸­æ·»åŠ ç‰ˆæƒæˆ–æ¥æºä¿¡æ¯
3. **å“ç‰Œæ ‡è¯†**ï¼šä¸ºä¼ä¸šå†…å®¹æ·»åŠ å“ç‰Œwatermarkæˆ–logoæ–‡å­—
4. **æ³•å¾‹åˆè§„**ï¼šæ»¡è¶³ä¸åŒåœ°åŒºå¯¹AIç”Ÿæˆå†…å®¹æ ‡è¯†çš„æ³•å¾‹è¦æ±‚
5. **å†…å®¹æº¯æº**ï¼šä¸ºå†…å®¹æ·»åŠ ç”Ÿæˆæ—¶é—´ã€æ¨¡å‹ç‰ˆæœ¬ç­‰å…ƒä¿¡æ¯

### æŠ€æœ¯ç‰¹ç‚¹æ€»ç»“

| ç‰¹æ€§ | æè¿° | ä¼˜åŠ¿ |
|------|------|------|
| **å¤šæ¨¡æ€ç»Ÿä¸€** | æ”¯æŒæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘ã€è§†é¢‘å››ç§æ¨¡æ€ | ä¸€è‡´çš„APIæ¥å£ï¼Œä¾¿äºé›†æˆ |
| **çµæ´»é…ç½®** | æ”¯æŒä½ç½®ã€æ ·å¼ã€æ—¶é•¿ç­‰å¤šç»´åº¦é…ç½® | é€‚åº”ä¸åŒåº”ç”¨åœºæ™¯éœ€æ±‚ |
| **é«˜è´¨é‡è¾“å‡º** | æŠ—é”¯é½¿ã€é˜´å½±æ•ˆæœã€æ ¼å¼ä¼˜åŒ– | ä¸“ä¸šçº§è§†è§‰æ•ˆæœ |
| **æµè§ˆå™¨å…¼å®¹** | è‡ªåŠ¨æ ¼å¼è½¬ç ï¼Œç¡®ä¿Webæ’­æ”¾ | æ— ç¼Webé›†æˆä½“éªŒ |
| **åˆè§„å¯¼å‘** | å†…ç½®æ ‡å‡†åˆè§„æ–‡æ¡ˆå’Œä½ç½® | æ»¡è¶³ç›‘ç®¡è¦æ±‚ |
| **æ‰¹é‡å¤„ç†** | æ”¯æŒAPIæ‰¹é‡è°ƒç”¨å’Œå¤„ç† | é«˜æ•ˆçš„ç”Ÿäº§ç¯å¢ƒåº”ç”¨ |