# ç®€åŒ–ç‰ˆå¤šæ¨¡æ€æ°´å°å·¥å…·è®¾è®¡

## ğŸ¯ é¡¹ç›®ç›®æ ‡

å¼€å‘ä¸€ä¸ªç®€å•æ˜“ç”¨çš„å¤šæ¨¡æ€æ°´å°å·¥å…·ï¼Œæ”¯æŒï¼š
- **æ–‡æœ¬æ°´å°**ï¼šåŸºäºCredIDç®—æ³•
- **å›¾åƒæ°´å°**ï¼šåŸºäºStable Signatureç®—æ³•
- **ç»Ÿä¸€æ¥å£**ï¼šæä¾›ä¸€è‡´çš„åµŒå…¥å’Œæå–API

## ğŸ“ ç®€åŒ–ç›®å½•ç»“æ„

```
mmwt/                           # å¤šæ¨¡æ€æ°´å°å·¥å…·
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ setup.py
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ text_config.yaml       # æ–‡æœ¬æ°´å°é…ç½®
â”‚   â””â”€â”€ image_config.yaml      # å›¾åƒæ°´å°é…ç½®
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ watermark_engine.py    # ç»Ÿä¸€æ°´å°å¼•æ“
â”‚   â”œâ”€â”€ text_watermark/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ credid_watermark.py # CredIDç®—æ³•å°è£…
â”‚   â”‚   â””â”€â”€ credid/             # CredIDç®—æ³•å®ç°ï¼ˆä»åŸé¡¹ç›®å¤åˆ¶ï¼‰
â”‚   â”œâ”€â”€ image_watermark/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ stable_signature.py # Stable Signatureç®—æ³•å°è£…
â”‚   â”‚   â””â”€â”€ stable_sig/         # Stable Signatureå®ç°ï¼ˆä»åŸé¡¹ç›®å¤åˆ¶ï¼‰
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ config_loader.py    # é…ç½®åŠ è½½
â”‚       â””â”€â”€ model_manager.py    # æ¨¡å‹ç®¡ç†
â”œâ”€â”€ examples/
â”‚   â”œâ”€â”€ text_demo.py           # æ–‡æœ¬æ°´å°æ¼”ç¤º
â”‚   â”œâ”€â”€ image_demo.py          # å›¾åƒæ°´å°æ¼”ç¤º
â”‚   â””â”€â”€ unified_demo.py        # ç»Ÿä¸€æ¥å£æ¼”ç¤º
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_text_watermark.py
â”‚   â””â”€â”€ test_image_watermark.py
â””â”€â”€ models/                    # é¢„è®­ç»ƒæ¨¡å‹å­˜å‚¨
```

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

æœ¬å·¥å…·é‡‡ç”¨**åˆ†å±‚æ¨¡å—åŒ–æ¶æ„**ï¼Œä»ä¸Šåˆ°ä¸‹åˆ†ä¸ºï¼š
1. **ç”¨æˆ·æ¥å£å±‚**ï¼šæä¾›ç»Ÿä¸€çš„APIæ¥å£å’Œä½¿ç”¨ç¤ºä¾‹
2. **æ ¸å¿ƒå¼•æ“å±‚**ï¼šWatermarkEngineç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ°´å°æ“ä½œ
3. **ç®—æ³•å®ç°å±‚**ï¼šå…·ä½“çš„æ°´å°ç®—æ³•å°è£…å’Œå®ç°
4. **é…ç½®å’Œå·¥å…·å±‚**ï¼šé…ç½®ç®¡ç†ã€æ¨¡å‹ç®¡ç†ç­‰æ”¯æŒç»„ä»¶

### 1. ç»Ÿä¸€æ°´å°å¼•æ“ (WatermarkEngine)

**è®¾è®¡ç†å¿µ**ï¼š
- **å•ä¸€å…¥å£**ï¼šç”¨æˆ·åªéœ€è¦ä¸WatermarkEngineäº¤äº’ï¼Œæ— éœ€å…³å¿ƒåº•å±‚å®ç°
- **æ‡’åŠ è½½**ï¼šåªæœ‰åœ¨å®é™…ä½¿ç”¨æ—¶æ‰åŠ è½½å¯¹åº”çš„ç®—æ³•æ¨¡å—ï¼ŒèŠ‚çœå†…å­˜
- **é…ç½®é©±åŠ¨**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶ç®¡ç†ä¸åŒç®—æ³•çš„å‚æ•°

**æ ¸å¿ƒå®ç°**ï¼š

```python
# src/watermark_engine.py
import os
import yaml
from typing import Optional, Dict, Any

class WatermarkEngine:
    """
    å¤šæ¨¡æ€æ°´å°ç»Ÿä¸€å¼•æ“
    
    åŠŸèƒ½èŒè´£ï¼š
    1. æä¾›ç»Ÿä¸€çš„æ–‡æœ¬å’Œå›¾åƒæ°´å°æ¥å£
    2. ç®¡ç†ç®—æ³•æ¨¡å—çš„æ‡’åŠ è½½
    3. å¤„ç†é…ç½®æ–‡ä»¶çš„åŠ è½½å’ŒéªŒè¯
    4. åè°ƒä¸åŒæ¨¡æ€é—´çš„æ“ä½œ
    """
    
    def __init__(self, base_dir: str = "."):
        """
        åˆå§‹åŒ–æ°´å°å¼•æ“
        
        Args:
            base_dir: é¡¹ç›®æ ¹ç›®å½•ï¼Œç”¨äºå®šä½é…ç½®æ–‡ä»¶
        """
        self.base_dir = base_dir
        self.text_watermark = None      # æ–‡æœ¬æ°´å°æ¨¡å—å®ä¾‹
        self.image_watermark = None     # å›¾åƒæ°´å°æ¨¡å—å®ä¾‹
        self._config_cache = {}         # é…ç½®æ–‡ä»¶ç¼“å­˜
    
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """
        åŠ è½½å¹¶ç¼“å­˜é…ç½®æ–‡ä»¶
        
        Args:
            config_path: é…ç½®æ–‡ä»¶è·¯å¾„
            
        Returns:
            è§£æåçš„é…ç½®å­—å…¸
        """
        if config_path not in self._config_cache:
            full_path = os.path.join(self.base_dir, config_path)
            with open(full_path, 'r', encoding='utf-8') as f:
                self._config_cache[config_path] = yaml.safe_load(f)
        return self._config_cache[config_path]
    
    def setup_text_watermark(self, config_path: str = "config/text_config.yaml"):
        """
        åˆå§‹åŒ–æ–‡æœ¬æ°´å°æ¨¡å—
        
        Args:
            config_path: æ–‡æœ¬æ°´å°é…ç½®æ–‡ä»¶è·¯å¾„
        """
        from .text_watermark.credid_watermark import CredIDWatermark
        config = self._load_config(config_path)
        self.text_watermark = CredIDWatermark(config)
    
    def setup_image_watermark(self, config_path: str = "config/image_config.yaml"):
        """
        åˆå§‹åŒ–å›¾åƒæ°´å°æ¨¡å—
        
        Args:
            config_path: å›¾åƒæ°´å°é…ç½®æ–‡ä»¶è·¯å¾„
        """
        from .image_watermark.stable_signature import StableSignatureWatermark
        config = self._load_config(config_path)
        self.image_watermark = StableSignatureWatermark(config)
    
    # === æ–‡æœ¬æ°´å°æ¥å£ ===
    def embed_text(self, model, tokenizer, prompt: str, message: str) -> Dict[str, Any]:
        """
        åµŒå…¥æ–‡æœ¬æ°´å°
        
        Args:
            model: é¢„è®­ç»ƒè¯­è¨€æ¨¡å‹ (HuggingFace model)
            tokenizer: å¯¹åº”çš„åˆ†è¯å™¨
            prompt: è¾“å…¥æç¤ºæ–‡æœ¬
            message: è¦åµŒå…¥çš„æ°´å°ä¿¡æ¯
            
        Returns:
            åŒ…å«æ°´å°æ–‡æœ¬å’Œå…ƒæ•°æ®çš„å­—å…¸
        """
        if not self.text_watermark:
            self.setup_text_watermark()
        return self.text_watermark.embed(model, tokenizer, prompt, message)
    
    def extract_text(self, watermarked_text: str) -> Dict[str, Any]:
        """
        æå–æ–‡æœ¬æ°´å°
        
        Args:
            watermarked_text: å¸¦æœ‰æ°´å°çš„æ–‡æœ¬
            
        Returns:
            åŒ…å«æå–ä¿¡æ¯å’Œç½®ä¿¡åº¦çš„å­—å…¸
        """
        if not self.text_watermark:
            self.setup_text_watermark()
        return self.text_watermark.extract(watermarked_text)
    
    # === å›¾åƒæ°´å°æ¥å£ ===
    def embed_image(self, model, prompt: str, message: str) -> Dict[str, Any]:
        """
        åµŒå…¥å›¾åƒæ°´å°
        
        Args:
            model: æ‰©æ•£æ¨¡å‹ (å¦‚ Stable Diffusion)
            prompt: å›¾åƒç”Ÿæˆæç¤ºè¯
            message: è¦åµŒå…¥çš„æ°´å°ä¿¡æ¯
            
        Returns:
            åŒ…å«æ°´å°å›¾åƒå’Œå…ƒæ•°æ®çš„å­—å…¸
        """
        if not self.image_watermark:
            self.setup_image_watermark()
        return self.image_watermark.embed(model, prompt, message)
    
    def extract_image(self, watermarked_image) -> Dict[str, Any]:
        """
        æå–å›¾åƒæ°´å°
        
        Args:
            watermarked_image: å¸¦æœ‰æ°´å°çš„å›¾åƒ (PIL Image æˆ–è·¯å¾„)
            
        Returns:
            åŒ…å«æå–ä¿¡æ¯å’Œç½®ä¿¡åº¦çš„å­—å…¸
        """
        if not self.image_watermark:
            self.setup_image_watermark()
        return self.image_watermark.extract(watermarked_image)
    
    # === å·¥å…·æ–¹æ³• ===
    def get_config(self, config_type: str) -> Dict[str, Any]:
        """è·å–æŒ‡å®šç±»å‹çš„é…ç½®"""
        config_map = {
            'text': 'config/text_config.yaml',
            'image': 'config/image_config.yaml'
        }
        return self._load_config(config_map[config_type])
    
    def reset(self):
        """é‡ç½®å¼•æ“ï¼Œæ¸…ç©ºç¼“å­˜"""
        self.text_watermark = None
        self.image_watermark = None
        self._config_cache.clear()
```

### 2. æ–‡æœ¬æ°´å°æ¨¡å— (CredID Algorithm) âœ… **å·²å®ç°**

**CredIDç®—æ³•åŸç†**ï¼š
- **å¤šä½æ°´å°**ï¼šæ”¯æŒåµŒå…¥å¤šæ®µä¿¡æ¯ï¼ˆå¦‚ç”¨æˆ·IDã€æ—¶é—´æˆ³ã€ç‰ˆæœ¬å·ç­‰ï¼‰
- **logitså¤„ç†**ï¼šåœ¨è¯­è¨€æ¨¡å‹çš„logitsè¾“å‡ºä¸Šè¿›è¡Œä¿®æ”¹ï¼Œå½±å“tokené€‰æ‹©æ¦‚ç‡
- **åŒæ¨¡å¼æ”¯æŒ**ï¼šLMæ¨¡å¼ï¼ˆé«˜è´¨é‡ï¼‰å’ŒRandomæ¨¡å¼ï¼ˆé«˜æ•ˆç‡ï¼‰
- **å€™é€‰ä¼˜åŒ–**ï¼šæ”¯æŒå€™é€‰æ¶ˆæ¯åˆ—è¡¨çš„é™åˆ¶æœç´¢ï¼Œæå‡æ£€æµ‹æ•ˆç‡
- **æ™ºèƒ½åˆ†å‰²**ï¼šè‡ªåŠ¨å¤„ç†å¤æ‚æ¶ˆæ¯æ ¼å¼ï¼ˆå¦‚"log20250725143000"ï¼‰

**å®é™…å®ç°çš„æ ¸å¿ƒæ¶æ„**ï¼š

```python
# src/text_watermark/credid_watermark.py
import torch
import logging
from typing import Dict, Any, List, Optional, Union, Tuple
from transformers import PreTrainedModel, PreTrainedTokenizer, LogitsProcessorList

class CredIDWatermark:
    """
    CredIDæ–‡æœ¬æ°´å°ç®—æ³•ç»Ÿä¸€å°è£…
    
    âœ¨ æ ¸å¿ƒåŠŸèƒ½ç‰¹ç‚¹:
    1. æ”¯æŒå¤šç§æ¶ˆæ¯æ ¼å¼ (å­—ç¬¦ä¸²ã€æ•´æ•°åˆ—è¡¨ã€å­—ç¬¦ä¸²åˆ—è¡¨)
    2. åŒæ¨¡å¼è¿è¡Œ: LMæ¨¡å¼(é«˜è´¨é‡) / Randomæ¨¡å¼(é«˜æ•ˆç‡)
    3. æ™ºèƒ½å¤šæ®µæ¶ˆæ¯å¤„ç†å’Œè‡ªåŠ¨åˆ†å‰²
    4. å€™é€‰æ¶ˆæ¯ä¼˜åŒ–æœç´¢æœºåˆ¶
    5. å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œç½®ä¿¡åº¦è¯„ä¼°
    6. ç®€åŒ–çš„ä»£ç ç»“æ„ï¼Œå»é™¤å¤æ‚çš„æŒ‰ä½ç½®åˆ†ç»„é€»è¾‘
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        åˆå§‹åŒ–CredIDæ°´å°å¤„ç†å™¨
        
        Args:
            config: é…ç½®å­—å…¸ï¼Œå¿…é¡»åŒ…å«:
                - mode: 'lm' æˆ– 'random' (é»˜è®¤'lm')
                - model_name: é¢„è®­ç»ƒæ¨¡å‹åç§°
                - lm_params: LMæ¨¡å¼å‚æ•°å­—å…¸
                - wm_params: æ°´å°å¤„ç†å‚æ•°å­—å…¸
                - å…¶ä»–ç”Ÿæˆå‚æ•° (max_new_tokens, num_beamsç­‰)
        """
        self.config = config
        self.mode = config.get('mode', 'lm')  # é»˜è®¤LMæ¨¡å¼
        self.model_name = config.get('model_name', 'huggyllama/llama-7b')
        
        # ç®—æ³•æ ¸å¿ƒå‚æ•°
        self.lm_params = config.get('lm_params', {})
        self.wm_params = config.get('wm_params', {})
        
        # å»¶è¿Ÿåˆå§‹åŒ–çš„ç»„ä»¶
        self.message_model = None
        self.tokenizer_ref = None
        
        logging.info(f"CredIDåˆå§‹åŒ–: æ¨¡å¼={self.mode}, æ¨¡å‹={self.model_name}")
```

**ğŸ”¹ æ ¸å¿ƒæ¥å£ 1: embed() - æ°´å°åµŒå…¥**

```python
    def embed(self, model: PreTrainedModel, tokenizer: PreTrainedTokenizer, 
              prompt: str, message: Union[str, List[int], List[str]], 
              segmentation_mode: str = 'auto') -> Dict[str, Any]:
        """
        ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: åœ¨æ–‡æœ¬ç”Ÿæˆè¿‡ç¨‹ä¸­åµŒå…¥æ°´å°
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. è®¾ç½®å¤„ç†å™¨ (å¦‚æœè¿˜æ²¡è®¾ç½®)
        2. å°†æ¶ˆæ¯è½¬æ¢ä¸ºCredIDå…¼å®¹çš„äºŒè¿›åˆ¶æ ¼å¼ (æ”¯æŒå¤šæ®µ)
        3. åˆ›å»ºåŒ…å«æ°´å°å¤„ç†å™¨çš„LogitsProcessorList
        4. ä½¿ç”¨model.generate()ç”Ÿæˆå¸¦æ°´å°æ–‡æœ¬
        5. è¿”å›å®Œæ•´ç»“æœå’Œè¯¦ç»†å…ƒæ•°æ®
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            model: HuggingFaceé¢„è®­ç»ƒè¯­è¨€æ¨¡å‹ (å¦‚Llama, GPTç­‰)
            tokenizer: å¯¹åº”çš„åˆ†è¯å™¨ï¼Œå¿…é¡»è®¾ç½®pad_token
            prompt: è¾“å…¥æç¤ºæ–‡æœ¬ï¼Œå¦‚ "Hello, today is"
            message: æ°´å°ä¿¡æ¯ï¼Œæ”¯æŒå¤šç§æ ¼å¼:
                - str: "hello" æˆ–å¤æ‚å­—ç¬¦ä¸² "log20250725143000"
                - List[int]: [123, 456, 789] 
                - List[str]: ["user", "2025", "admin"]
            segmentation_mode: æ¶ˆæ¯åˆ†å‰²æ¨¡å¼
                - 'auto': è‡ªåŠ¨åˆ¤æ–­æœ€ä½³åˆ†å‰²æ–¹å¼ (æ¨è)
                - 'smart': æ™ºèƒ½åˆ†å‰²ï¼Œå¦‚ "alibaba20250725" â†’ ["alibaba", "2025", "0725"]
                - 'whole': æ•´ä½“å¤„ç†
                - 'spaces': æŒ‰ç©ºæ ¼åˆ†å‰²
                
        ğŸ“¤ è¿”å›å€¼ç»“æ„:
            {
                'watermarked_text': str,      # ğŸ¯ å¸¦æ°´å°çš„ç”Ÿæˆæ–‡æœ¬
                'original_message': Any,      # åŸå§‹æ°´å°ä¿¡æ¯
                'binary_message': List[int],  # è½¬æ¢åçš„äºŒè¿›åˆ¶æ¶ˆæ¯åºåˆ—
                'prompt': str,                # è¾“å…¥æç¤º
                'success': bool,              # âœ…/âŒ æ˜¯å¦æˆåŠŸ
                'metadata': {                 # è¯¦ç»†å…ƒæ•°æ®
                    'mode': str,              # ä½¿ç”¨çš„æ¨¡å¼ ('lm'/'random')
                    'model_name': str,        # æ¨¡å‹åç§°
                    'input_length': int,      # è¾“å…¥tokené•¿åº¦
                    'output_length': int,     # è¾“å‡ºtokené•¿åº¦
                    'generation_config': dict,# ç”Ÿæˆé…ç½®å‚æ•°
                    'num_message_segments': int # æ¶ˆæ¯æ®µæ•°
                }
            }
            
        ğŸš¨ é”™è¯¯æƒ…å†µè¿”å›:
            {
                'watermarked_text': None,
                'success': False,
                'error': str                  # é”™è¯¯ä¿¡æ¯
            }
        """
```

**ğŸ”¹ æ ¸å¿ƒæ¥å£ 2: extract() - æ°´å°æå–**

```python
    def extract(self, watermarked_text: str, 
                model: Optional[PreTrainedModel] = None,
                tokenizer: Optional[PreTrainedTokenizer] = None,
                candidates_messages: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        ğŸ¯ æ ¸å¿ƒåŠŸèƒ½: ä»æ°´å°æ–‡æœ¬ä¸­æå–æ°´å°ä¿¡æ¯
        
        ğŸ“‹ è¯¦ç»†å·¥ä½œæµç¨‹:
        1. æ£€æŸ¥æ¨¡å¼å’Œå‚æ•°æœ‰æ•ˆæ€§ (LMæ¨¡å¼éœ€è¦modelå’Œtokenizer)
        2. å€™é€‰æ¶ˆæ¯å¤„ç†: æ”¶é›†æ‰€æœ‰å€™é€‰æ¶ˆæ¯çš„æ‰€æœ‰ç¼–ç æ®µ (ç®€åŒ–ç­–ç•¥)
        3. ä½¿ç”¨CredIDè§£ç å™¨è¿›è¡Œç»Ÿè®¡æ£€æµ‹
        4. æ™ºèƒ½åŒ¹é…: å°†è§£ç ç»“æœä¸å€™é€‰æ¶ˆæ¯è¿›è¡Œåºåˆ—åŒ¹é…
        5. ç½®ä¿¡åº¦è®¡ç®—å’Œç»“æœéªŒè¯
        
        ğŸ“¥ å‚æ•°è¯´æ˜:
            watermarked_text: å¯èƒ½åŒ…å«æ°´å°çš„æ–‡æœ¬
            model: è¯­è¨€æ¨¡å‹ (LMæ¨¡å¼å¿…éœ€ï¼ŒRandomæ¨¡å¼å¯é€‰)
            tokenizer: åˆ†è¯å™¨ (LMæ¨¡å¼å¿…éœ€ï¼ŒRandomæ¨¡å¼å¯é€‰)
            candidates_messages: å€™é€‰æ¶ˆæ¯åˆ—è¡¨ï¼Œç”¨äºä¼˜åŒ–æœç´¢
                ğŸ¯ æ¨èä½¿ç”¨: å¯å¤§å¹…æå‡æ£€æµ‹ç²¾åº¦å’Œæ•ˆç‡
                ä¾‹å¦‚: ["log20250725143000", "user987654321", "admin2025"]
                
        ğŸ“¤ è¿”å›å€¼ç»“æ„:
            {
                'extracted_message': str,           # ğŸ¯ æå–çš„æ¶ˆæ¯
                'binary_message': List[int],        # è§£ç çš„äºŒè¿›åˆ¶æ¶ˆæ¯åºåˆ—
                'confidence': float,                # ğŸšï¸ ç½®ä¿¡åº¦ (0.0-1.0)
                'success': bool,                    # âœ…/âŒ æ˜¯å¦æˆåŠŸæå–
                'detailed_confidence': List,       # è¯¦ç»†ç½®ä¿¡åº¦ä¿¡æ¯
                'metadata': {
                    'mode': str,                    # æ£€æµ‹æ¨¡å¼
                    'text_length': int,             # æ–‡æœ¬é•¿åº¦
                    'num_decoded_segments': int,    # è§£ç æ®µæ•°
                    'detection_method': 'CredID',   # æ£€æµ‹æ–¹æ³•
                    'confidence_threshold': float,  # ç½®ä¿¡åº¦é˜ˆå€¼
                    'search_space': int,            # æœç´¢ç©ºé—´å¤§å°
                    'candidates_provided': bool     # æ˜¯å¦æä¾›å€™é€‰æ¶ˆæ¯
                }
            }
            
        ğŸš¨ å¤±è´¥æƒ…å†µè¿”å›:
            {
                'extracted_message': None,
                'confidence': 0.0,
                'success': False,
                'error': str                        # é”™è¯¯æˆ–"No watermark detected"
            }
        """
```

**ğŸ”§ æ ¸å¿ƒå†…éƒ¨æ–¹æ³•**

```python
    # === æ¶ˆæ¯å¤„ç†æ–¹æ³• ===
    def _message_to_binary(self, message: Union[str, List[int], List[str]], 
                          segmentation_mode: str = 'auto') -> List[int]:
        """å°†å¤šç§æ ¼å¼çš„æ¶ˆæ¯è½¬æ¢ä¸ºCredIDå…¼å®¹çš„æ•´æ•°åºåˆ—"""
        
    def _binary_to_message(self, binary: List[int]) -> Union[str, List[str]]:
        """å°†è§£ç çš„æ•´æ•°åºåˆ—è½¬æ¢å›åŸå§‹æ¶ˆæ¯æ ¼å¼"""
        
    # === æ™ºèƒ½åŒ¹é…æ–¹æ³• ===  
    def _match_decoded_with_candidates(self, decoded_messages: List[int], 
                                     candidates_messages: List[str]) -> Tuple[str, float]:
        """å°†è§£ç ç»“æœä¸å€™é€‰æ¶ˆæ¯è¿›è¡Œæ™ºèƒ½åŒ¹é… (ç®€åŒ–ç‰ˆæœ¬)"""
        
    def _calculate_sequence_match(self, decoded: List[int], candidate: List[int]) -> float:
        """è®¡ç®—ä¸¤ä¸ªåºåˆ—çš„åŒ¹é…åº¦åˆ†æ•°"""
        
    # === å­—ç¬¦ä¸²åˆ†å‰²æ–¹æ³• ===
    def _smart_segment_string(self, text: str) -> List[str]:
        """æ™ºèƒ½åˆ†å‰²å­—ç¬¦ä¸²ï¼Œæ”¯æŒå¤æ‚æ ¼å¼å¦‚'log20250725143000'"""
```

**âš™ï¸ é…ç½®å‚æ•°è¯¦è§£**

```yaml
# config/text_config.yaml - å®Œæ•´é…ç½®ç¤ºä¾‹
method: "CredID"
model_name: "huggyllama/llama-7b"          
mode: "lm"                                 # 'lm'(é«˜è´¨é‡) / 'random'(é«˜æ•ˆç‡)
device: "auto"                             

# === ç”Ÿæˆå‚æ•° ===
max_new_tokens: 110                        
num_beams: 4                               
do_sample: true                            
temperature: 0.7                           
top_p: 0.9                                
top_k: 50                                 

# === CredID LMæ¨¡å¼æ ¸å¿ƒå‚æ•° ===
lm_params:
  delta: 1.5                              # logitsä¿®æ”¹å¼ºåº¦ (å…³é”®å‚æ•°)
  prefix_len: 10                          # å‰ç¼€ä¿æŠ¤é•¿åº¦
  message_len: 10                         # æ¯æ®µæ¶ˆæ¯çš„äºŒè¿›åˆ¶é•¿åº¦
  seed: 42                                # éšæœºç§å­
  topk: -1                               # LM top-ké™åˆ¶
  permutation_num: 50                     # éšæœºæ’åˆ—æ•°
  hash_prefix_len: 1                      # å“ˆå¸Œå‰ç¼€é•¿åº¦
  shifts: [21, 24, 3, 8, 14, 2, 4, 28, 31, 3, 8, 14, 2, 4, 28]

# === æ°´å°å¤„ç†å‚æ•° ===
wm_params:
  encode_ratio: 8                         # ç¼–ç æ¯”ç‡ (æ¯æ¶ˆæ¯ä½å¯¹åº”çš„tokenæ•°)
  seed: 42                                
  strategy: "vanilla"                     # 'vanilla'/'max_confidence'
  max_confidence: 0.5                     
  top_k: 1000                            

# === è§£ç é…ç½® ===
decode_batch_size: 16                      
disable_tqdm: false                        
confidence_threshold: 0.6                  # æˆåŠŸæ£€æµ‹çš„ç½®ä¿¡åº¦é˜ˆå€¼
```

**ğŸš€ å®é™…ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µ**

```python
# === å®Œæ•´ä½¿ç”¨ç¤ºä¾‹ ===
from src.text_watermark.credid_watermark import CredIDWatermark
from transformers import AutoModelForCausalLM, AutoTokenizer
import yaml

# 1. åˆå§‹åŒ–ç³»ç»Ÿ
with open('config/text_config.yaml', 'r') as f:
    config = yaml.safe_load(f)

model = AutoModelForCausalLM.from_pretrained("huggyllama/llama-7b")
tokenizer = AutoTokenizer.from_pretrained("huggyllama/llama-7b")
if tokenizer.pad_token is None:
    tokenizer.pad_token = tokenizer.eos_token

watermark = CredIDWatermark(config)

# 2. ğŸ¯ å•ä¸€æ¶ˆæ¯å¤„ç†
result = watermark.embed(model, tokenizer, "Hello, today is", "tech")
if result['success']:
    print(f"âœ… ç”Ÿæˆæ–‡æœ¬: {result['watermarked_text']}")
    
    # åŸºç¡€æå–
    extracted = watermark.extract(result['watermarked_text'], model, tokenizer)
    print(f"ğŸ“¤ æå–ç»“æœ: {extracted['extracted_message']} (ç½®ä¿¡åº¦: {extracted['confidence']:.3f})")

# 3. ğŸ¯ å¤æ‚æ¶ˆæ¯å¤„ç†
complex_messages = [
    ("ç³»ç»Ÿæ—¥å¿—", "log20250725143000"),
    ("ç”¨æˆ·ä¿¡æ¯", "alibaba20250725"),
    ("ç®¡ç†è´¦æˆ·", ["admin", "2025", "secure"])
]

for desc, message in complex_messages:
    result = watermark.embed(model, tokenizer, f"Entry: ", message)
    if result['success']:
        print(f"\n=== {desc} ===")
        print(f"æ¶ˆæ¯: {message}")
        print(f"ç”Ÿæˆ: {result['watermarked_text']}")
        
        # ğŸ¯ å€™é€‰ä¼˜åŒ–æå–
        candidates = ["log20250725143000", "alibaba20250725", "admin2025secure", "tech", "hello"]
        extracted = watermark.extract(
            result['watermarked_text'], 
            model, tokenizer, 
            candidates_messages=candidates
        )
        
        success_icon = "âœ…" if extracted['success'] else "âŒ"
        print(f"{success_icon} æå–: {extracted['extracted_message']} (ç½®ä¿¡åº¦: {extracted['confidence']:.3f})")

# 4. ğŸ¯ æ‰¹é‡å¤„ç†æ€§èƒ½æµ‹è¯•
import time

test_messages = ["hello", "tech2025", "user123", "log20250725143000"]
batch_start = time.time()

batch_results = []
for i, msg in enumerate(test_messages):
    embed_result = watermark.embed(model, tokenizer, f"Test {i}: ", msg)
    if embed_result['success']:
        extract_result = watermark.extract(embed_result['watermarked_text'], model, tokenizer)
        batch_results.append({
            'original': msg,
            'extracted': extract_result['extracted_message'],
            'confidence': extract_result['confidence'],
            'success': extract_result['success']
        })

batch_time = time.time() - batch_start
print(f"\nâ±ï¸ æ‰¹é‡å¤„ç†({len(test_messages)}æ¡): {batch_time:.2f}ç§’")

# 5. ğŸ¯ é”™è¯¯å¤„ç†ç¤ºä¾‹
try:
    # æ¨¡æ‹Ÿé”™è¯¯æƒ…å†µ
    error_result = watermark.extract("This text has no watermark", model, tokenizer)
    if not error_result['success']:
        print(f"âŒ æ£€æµ‹å¤±è´¥: {error_result.get('error', 'No watermark detected')}")
except Exception as e:
    print(f"ğŸš¨ å¼‚å¸¸å¤„ç†: {e}")
```

**ğŸ“Š æ€§èƒ½å’Œç‰¹ç‚¹æ€»ç»“**

| ç‰¹æ€§ | æè¿° | ä¼˜åŠ¿ |
|------|------|------|
| **å¤šæ¶ˆæ¯æ ¼å¼** | æ”¯æŒå­—ç¬¦ä¸²ã€åˆ—è¡¨ã€å¤æ‚æ ¼å¼ | çµæ´»æ€§é«˜ï¼Œé€‚åº”ä¸åŒåœºæ™¯ |
| **åŒæ¨¡å¼è¿è¡Œ** | LMæ¨¡å¼(é«˜è´¨é‡) / Randomæ¨¡å¼(é«˜æ•ˆç‡) | å¹³è¡¡è´¨é‡å’Œæ€§èƒ½ |
| **å€™é€‰ä¼˜åŒ–** | é™åˆ¶æœç´¢ç©ºé—´æå‡æ•ˆç‡ | å¤§å¹…æå‡æ£€æµ‹ç²¾åº¦ |
| **æ™ºèƒ½åˆ†å‰²** | è‡ªåŠ¨å¤„ç†å¤æ‚æ¶ˆæ¯æ ¼å¼ | æ— éœ€æ‰‹åŠ¨é¢„å¤„ç† |
| **ç®€åŒ–æ¶æ„** | å»é™¤å¤æ‚çš„æŒ‰ä½ç½®åˆ†ç»„é€»è¾‘ | ä»£ç æ›´æ¸…æ™°ï¼Œç»´æŠ¤æ€§å¥½ |
| **é”™è¯¯å¤„ç†** | å®Œæ•´çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ | ç”Ÿäº§ç¯å¢ƒå¯é æ€§é«˜ |
| **æ€§èƒ½ç›‘æ§** | å†…ç½®æ—¶é—´å’Œèµ„æºä½¿ç”¨ç»Ÿè®¡ | ä¾¿äºæ€§èƒ½è°ƒä¼˜ |

**ğŸ¯ ä¸ºå›¾åƒæ°´å°å’Œç»Ÿä¸€å¼•æ“æä¾›çš„è®¾è®¡å‚è€ƒ:**

1. **ğŸ—ï¸ ç»Ÿä¸€æ¥å£æ¨¡å¼**: `embed(model, tokenizer, prompt, message)` â†’ `extract(text, model, tokenizer, candidates)`
2. **âš™ï¸ é…ç½®é©±åŠ¨è®¾è®¡**: é€šè¿‡YAMLæ–‡ä»¶ç®¡ç†æ‰€æœ‰ç®—æ³•å‚æ•°
3. **ğŸ“‹ æ ‡å‡†è¿”å›æ ¼å¼**: ç»Ÿä¸€çš„ `{success, result, metadata, error}` ç»“æ„
4. **ğŸ” å€™é€‰ä¼˜åŒ–æœºåˆ¶**: æ”¯æŒå€™é€‰åˆ—è¡¨çš„é«˜æ•ˆæœç´¢ç­–ç•¥
5. **ğŸ¨ å¤šæ¨¡æ€æ¶ˆæ¯**: æ”¯æŒå¤šç§è¾“å…¥æ ¼å¼çš„æ™ºèƒ½ç¼–ç 
6. **ğŸ›¡ï¸ å¥å£®é”™è¯¯å¤„ç†**: è¯¦ç»†çš„çŠ¶æ€æŠ¥å‘Šå’Œå¼‚å¸¸ç®¡ç†
7. **ğŸ“ˆ æ€§èƒ½ç›‘æ§**: å†…ç½®æ—¶é—´å’Œèµ„æºä½¿ç”¨ç»Ÿè®¡

è¿™ä¸ªè®¾è®¡ä¸ºåç»­å›¾åƒæ°´å°æ¨¡å—å’Œç»Ÿä¸€å¼•æ“æä¾›äº†æ¸…æ™°çš„æ¶æ„æ¨¡æ¿ï¼ğŸš€ 